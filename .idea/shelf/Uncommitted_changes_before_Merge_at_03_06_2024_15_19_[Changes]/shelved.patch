Index: src/main/java/biletka/main/controller/EventController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.controller;\r\n\r\nimport biletka.main.Utils.ConvertUtils;\r\nimport biletka.main.dto.request.EventCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.universal.MassivePublicEvent;\r\nimport biletka.main.dto.universal.PublicEventImage;\r\nimport biletka.main.dto.universal.PublicFullInfoEvent;\r\nimport biletka.main.service.EventService;\r\nimport io.swagger.v3.oas.annotations.Operation;\r\nimport io.swagger.v3.oas.annotations.Parameter;\r\nimport io.swagger.v3.oas.annotations.tags.Tag;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.format.annotation.DateTimeFormat;\r\nimport org.springframework.http.HttpRequest;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.IOException;\r\nimport java.net.http.HttpResponse;\r\nimport java.sql.Timestamp;\r\nimport java.util.Date;\r\n\r\n@Slf4j\r\n@RestController\r\n@RequestMapping(\"/event\")\r\n@RequiredArgsConstructor\r\n@Tag(name = \"Контроллер ивентов\", description = \"Всё, что связано с ивентами\")\r\n@CrossOrigin\r\npublic class EventController {\r\n    private final EventService eventService;\r\n\r\n    private final ConvertUtils convertToJSON;\r\n\r\n    @Operation(\r\n            summary = \"Создание мероприятия\",\r\n            description = \"Позволяет создать мероприятие\"\r\n    )\r\n    @PostMapping\r\n    public ResponseEntity<MessageCreateResponse> postEventCreate(@Parameter(description = \"токен пользователя\") @RequestHeader(\"Authorization\") String authorization,\r\n                                             @RequestPart(\"file\") MultipartFile file,\r\n                                             @RequestPart(\"event_create_request\") String eventCreateRequest) throws IOException {\r\n        log.trace(\"EventController.postEventCreate / - file {}, eventCreateRequest {}\", file, eventCreateRequest);\r\n        EventCreateRequest eventCreateRequestNew = convertToJSON.convertToJSONEventCreate(eventCreateRequest);\r\n        MessageCreateResponse message = eventService.createEvent(authorization, file, eventCreateRequestNew);\r\n\r\n        return ResponseEntity.status(HttpStatus.CREATED).body(message);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод 10 мероприятий\",\r\n            description = \"Вывод 10 мероприятий по городу\"\r\n    )\r\n    @GetMapping(\"/{cityName}\")\r\n    public ResponseEntity<MassivePublicEvent> getEventLimit(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                            @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                            @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                            @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventLimit / - cityName {}, authorization {}, offset {}, date {}\", cityName, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventLimit(cityName, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод 10 анонсов\",\r\n            description = \"Вывод 10 мероприятий по городу и будущим сеансам, которых не было\"\r\n    )\r\n    @GetMapping(\"/{cityName}/announcement\")\r\n    public ResponseEntity<MassivePublicEvent> getAnnouncementLimit(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                  @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                  @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                  @Parameter(description = \"дата для выборки\") @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date date) {\r\n        log.trace(\"EventController.getAnnouncementLimit / - cityName {}, authorization {}, offset {}, date {}\", cityName, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getAnnouncementLimit(cityName, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод полной информации о мероприятии\",\r\n            description = \"Вывод полной информации о мероприятии по id и символьному названию\"\r\n    )\r\n    @GetMapping(\"/{cityName}/{eventName}\")\r\n    public ResponseEntity<?> getFillInfoEvent(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                              @Parameter(description = \"название мероприятия\") @PathVariable String eventName,\r\n                                              @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                              @Parameter(description = \"дата для выборки\") @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date date) {\r\n        log.trace(\"EventController.getAnnouncementLimit / - cityName {}, eventName {}, authorization {}, date {}\", cityName, eventName, authorization, date);\r\n        PublicFullInfoEvent publicFullInfoEvent = eventService.getFullInfoEvent(authorization, cityName, eventName, date);\r\n        return ResponseEntity.ok(publicFullInfoEvent);\r\n    }\r\n\r\n    @CrossOrigin\r\n    @Operation(\r\n            summary = \"Вывод изображения мероприятия\",\r\n            description = \"Вывод изображения мероприятия\"\r\n    )\r\n    @GetMapping(\"/img/{id}>>{symbolicName}\")\r\n    public void getImageEvent(@PathVariable String id,\r\n                              @PathVariable String symbolicName,\r\n                              HttpServletResponse response) throws IOException {\r\n        log.trace(\"EventController.getImageEvent  /img/{id}-{symbolicName} - id {}, symbolicName {}\", id, symbolicName);\r\n        PublicEventImage publicEventImage = eventService.getImageEvent(id, symbolicName);\r\n        response.setContentType(publicEventImage.type());\r\n        response.getOutputStream().write(publicEventImage.imageData());\r\n        response.getOutputStream().close();\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод мероприятий по возрасту\",\r\n            description = \"Вывод мероприятий по указанному возрасту\"\r\n    )\r\n    @GetMapping(\"/{cityName}/age\")\r\n    public ResponseEntity<MassivePublicEvent> getEventByAge(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                            @Parameter(description = \"возраст\") @RequestParam int age,\r\n                                                            @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                            @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                            @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventByAge / - cityName {} / - age {}, authorization {}, offset {}, date {}\", cityName, age, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventsByCityAndAgeLimit(cityName, age, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n            @Operation(\r\n            summary = \"Вывод мероприятий по типу\",\r\n            description = \"Вывод мероприятий по указанному типу\"\r\n    )\r\n    @GetMapping(\"/{cityName}/type\")\r\n    public ResponseEntity<MassivePublicEvent> getEventByType(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                            @Parameter(description = \"тип\") @RequestParam String type,\r\n                                                            @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                            @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                            @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventByType / - cityName {} / - type {}, authorization {}, offset {}, date {}\", cityName, type, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventsByCityAndType(cityName, type, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n\r\n    @Operation(\r\n            summary = \"Вывод мероприятий по жанру\",\r\n            description = \"Вывод мероприятий по указанному женру\"\r\n    )\r\n    @GetMapping(\"/{cityName}/genre\")\r\n    public ResponseEntity<MassivePublicEvent> getEventByGenre(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                             @Parameter(description = \"жанр\") @RequestParam String genre,\r\n                                                             @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                             @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                             @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventByGenre / - cityName {} / - genre {}, authorization {}, offset {}, date {}\", cityName, genre, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventsByCityAndGenre(cityName, genre, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/controller/EventController.java b/src/main/java/biletka/main/controller/EventController.java
--- a/src/main/java/biletka/main/controller/EventController.java	
+++ b/src/main/java/biletka/main/controller/EventController.java	
@@ -2,11 +2,16 @@
 
 import biletka.main.Utils.ConvertUtils;
 import biletka.main.dto.request.EventCreateRequest;
+import biletka.main.dto.response.GenreResponse;
+import biletka.main.dto.response.MassiveGenreResponse;
+import biletka.main.dto.response.MassiveTypeResponse;
 import biletka.main.dto.response.MessageCreateResponse;
 import biletka.main.dto.universal.MassivePublicEvent;
 import biletka.main.dto.universal.PublicEventImage;
 import biletka.main.dto.universal.PublicFullInfoEvent;
 import biletka.main.service.EventService;
+import biletka.main.service.GenreService;
+import biletka.main.service.TypeEventService;
 import io.swagger.v3.oas.annotations.Operation;
 import io.swagger.v3.oas.annotations.Parameter;
 import io.swagger.v3.oas.annotations.tags.Tag;
@@ -34,6 +39,8 @@
 @CrossOrigin
 public class EventController {
     private final EventService eventService;
+    private final GenreService genreService;
+    private final TypeEventService typeEventService;
 
     private final ConvertUtils convertToJSON;
 
@@ -61,7 +68,7 @@
                                                             @Parameter(description = "токен пользователя") @RequestHeader(value = "Authorization", required = false) String authorization,
                                                             @Parameter(description = "отсчет мероприятий") @RequestParam Integer offset,
                                                             @Parameter(description = "дата для выборки") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {
-        log.trace("EventController.getEventLimit / - cityName {}, authorization {}, offset {}, date {}", cityName, authorization, offset, date);
+        log.trace("EventController.getEventLimit /cityName - cityName {}, authorization {}, offset {}, date {}", cityName, authorization, offset, date);
         MassivePublicEvent massivePublicEvent = eventService.getEventLimit(cityName, authorization, offset, date);
         return ResponseEntity.ok(massivePublicEvent);
     }
@@ -75,7 +82,7 @@
                                                   @Parameter(description = "токен пользователя") @RequestHeader(value = "Authorization", required = false) String authorization,
                                                   @Parameter(description = "отсчет мероприятий") @RequestParam Integer offset,
                                                   @Parameter(description = "дата для выборки") @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date date) {
-        log.trace("EventController.getAnnouncementLimit / - cityName {}, authorization {}, offset {}, date {}", cityName, authorization, offset, date);
+        log.trace("EventController.getAnnouncementLimit /cityName/announcement - cityName {}, authorization {}, offset {}, date {}", cityName, authorization, offset, date);
         MassivePublicEvent massivePublicEvent = eventService.getAnnouncementLimit(cityName, authorization, offset, date);
         return ResponseEntity.ok(massivePublicEvent);
     }
@@ -85,11 +92,11 @@
             description = "Вывод полной информации о мероприятии по id и символьному названию"
     )
     @GetMapping("/{cityName}/{eventName}")
-    public ResponseEntity<?> getFillInfoEvent(@Parameter(description = "название города") @PathVariable String cityName,
+    public ResponseEntity<PublicFullInfoEvent> getFullInfoEvent(@Parameter(description = "название города") @PathVariable String cityName,
                                               @Parameter(description = "название мероприятия") @PathVariable String eventName,
                                               @Parameter(description = "токен пользователя") @RequestHeader(value = "Authorization", required = false) String authorization,
                                               @Parameter(description = "дата для выборки") @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date date) {
-        log.trace("EventController.getAnnouncementLimit / - cityName {}, eventName {}, authorization {}, date {}", cityName, eventName, authorization, date);
+        log.trace("EventController.getAnnouncementLimit /cityName/eventName - cityName {}, eventName {}, authorization {}, date {}", cityName, eventName, authorization, date);
         PublicFullInfoEvent publicFullInfoEvent = eventService.getFullInfoEvent(authorization, cityName, eventName, date);
         return ResponseEntity.ok(publicFullInfoEvent);
     }
@@ -111,6 +118,7 @@
     }
 
     @Operation(
+<<<<<<< HEAD
             summary = "Вывод мероприятий по возрасту",
             description = "Вывод мероприятий по указанному возрасту"
     )
@@ -157,4 +165,26 @@
     }
 
 
+=======
+            summary = "Вывод жанров",
+            description = "Позволяет вывести все возможные жанры"
+    )
+    @GetMapping("/genre")
+    public ResponseEntity<MassiveGenreResponse> getAllGenre() {
+        log.trace("EventController.getAllGenre  /genre");
+        MassiveGenreResponse genres = genreService.getAllGenre();
+        return ResponseEntity.ok(genres);
+    }
+
+    @Operation(
+            summary = "Вывод типов мероприятия",
+            description = "Позволяет вывести все возможные типы мероприятий"
+    )
+    @GetMapping("/type")
+    public ResponseEntity<MassiveTypeResponse> getAllType() {
+        log.trace("EventController.getAllType  /type");
+        MassiveTypeResponse types = typeEventService.getAllType();
+        return ResponseEntity.ok(types);
+    }
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 }
Index: src/main/java/biletka/main/service/Impl/EventServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.FileUtils;\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.EventCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.response.TotalSession.EventsByPlace;\r\nimport biletka.main.dto.universal.*;\r\nimport biletka.main.entity.*;\r\nimport biletka.main.entity.event_item.EventAdditionalInformation;\r\nimport biletka.main.entity.event_item.EventBasicInformation;\r\nimport biletka.main.entity.event_item.EventWebWidget;\r\nimport biletka.main.enums.StatusEventEnum;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.EventRepository;\r\nimport biletka.main.service.*;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.IOException;\r\nimport java.sql.Timestamp;\r\nimport java.time.LocalDateTime;\r\nimport java.util.*;\r\nimport java.util.regex.Pattern;\r\n\r\n@Service\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\n@Slf4j\r\npublic class EventServiceImpl implements EventService {\r\n    private final FileUtils fileUtils;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final EventRepository eventRepository;\r\n\r\n    private final EventBasicInformationService eventBasicInformationService;\r\n    private final EventAdditionalInformationService eventAdditionalInformationService;\r\n    private final EventWebWidgetService eventWebWidgetService;\r\n    private final UserService userService;\r\n    private final OrganizationService organizationService;\r\n    private final CityService cityService;\r\n    private final ClientService clientService;\r\n    private final GenreService genreService;\r\n    @Lazy\r\n    private final SessionService sessionService;\r\n\r\n    /**\r\n     * Метод создания и добавления мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param file изображение мероприятия\r\n     * @param eventCreateRequest информация мероприятия\r\n     * @return сообщение оуспешном создании мероприятия\r\n     */\r\n    @Override\r\n    public MessageCreateResponse createEvent(String authorization, MultipartFile file, EventCreateRequest eventCreateRequest) throws IOException {\r\n        log.trace(\"EventServiceImpl.createEvent - authorization {}, file {}, eventCreateRequest {}\", authorization, file.getOriginalFilename(), eventCreateRequest);\r\n        /** Проверка на типа файла */\r\n        String typeFile = fileUtils.getFileExtension(file.getOriginalFilename());\r\n        ArrayList<String> pattern = new ArrayList<>();\r\n        pattern.add(\"png\");\r\n        pattern.add(\"jpg\");\r\n\r\n        fileUtils.validationFile(\r\n                typeFile,\r\n                new String[]{\"png\", \"jpg\"}\r\n        );\r\n\r\n        /**  Проверка на организацию пользователя*/\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = organizationService.getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        /** Проверка на существование мероприятия */\r\n        Event event = eventRepository.findFirstByName(eventCreateRequest.eventBasicRequest().name(), eventCreateRequest.eventBasicRequest().typeEvent());\r\n\r\n        if (event != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Create event error\", \"This event already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Создание дочерних элементов */\r\n        EventBasicInformation eventBasicInformation = eventBasicInformationService.createEventBasic(eventCreateRequest.eventBasicRequest(), file.getOriginalFilename());\r\n        EventAdditionalInformation eventAdditionalInformation = eventAdditionalInformationService.createEventAdditional(eventCreateRequest.eventAdditional());\r\n        EventWebWidget eventWebWidget = eventWebWidgetService.createEventWebWidget(eventCreateRequest.webWidget());\r\n\r\n        Event eventNew = new Event(\r\n                eventWebWidget,\r\n                eventAdditionalInformation,\r\n                eventBasicInformation,\r\n                eventCreateRequest.duration(),\r\n                0.0,\r\n                new Timestamp(new Date().getTime()),\r\n                StatusEventEnum.ACTIVE\r\n        );\r\n\r\n        eventRepository.saveAndFlush(eventNew);\r\n\r\n        /** Добавление мероприятия к организации */\r\n        organizationService.addEventAdmin(organization, eventNew);\r\n\r\n        /** Сохранение файла */\r\n        fileUtils.fileUpload(file, \"event/\" + eventNew.getId() + \"-\" + eventNew.getEventBasicInformation().getSymbolicName() + \".\" + typeFile);\r\n\r\n        return new MessageCreateResponse(\r\n                \"The event '\" + eventNew.getEventBasicInformation().getName() + \"' of the '\" + eventNew.getEventBasicInformation().getTypeEventId().getType() + \"' type has been successfully created!\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения мероприятия по id\r\n     * @param id мероприятия\r\n     * @return мероприятие\r\n     */\r\n    @Override\r\n    public Event getEventById(Long id) {\r\n        log.trace(\"EventServiceImpl.getEventById - id {}\", id);\r\n        return eventRepository.getReferenceById(id);\r\n    }\r\n\r\n    /**\r\n     * Метод получения изображения мероприятия\r\n     * @param id мероприятия\r\n     * @param symbolicName символичное название мероприятия\r\n     * @return данные для изображения\r\n     */\r\n    @Override\r\n    public PublicEventImage getImageEvent(String id, String symbolicName) throws EntityNotFoundException, IOException {\r\n        log.trace(\"EventServiceImpl.getImageEvent - id {}, symbolicName {}\", id, symbolicName);\r\n        Event event = eventRepository.findFirstByIdAndSymbolicName(Long.valueOf(id), symbolicName);\r\n\r\n        if (event == null) {\r\n            throw new EntityNotFoundException(\"The event not found!\");\r\n        }\r\n\r\n        return fileUtils.getFileEvent(event.getEventBasicInformation().getImg());\r\n    }\r\n\r\n    /**\r\n     * Метод получения кртакой информации о 10 мероприятиях по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getEventLimit(String cityName, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, offset {}, date {}\", cityName, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя*/\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n\r\n            favoriteSet.addAll(client.getEventSet());\r\n        }\r\n\r\n        Set<Event> events = sessionService.getMassiveEventByCityLimit(city, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /**\r\n     * Метод получения анонсов 10 мероприятий по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getAnnouncementLimit(String cityName, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.getAnnouncementLimit - cityName {}, offset {}, date {}\", cityName, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents = new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя*/\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n\r\n            favoriteSet.addAll(client.getEventSet());\r\n        }\r\n\r\n        Set<Event> events = sessionService.getMassiveAnnouncementByCityLimit(city, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /**\r\n     * Метод получения полной информации меропрития и места проведения и его сеансов\r\n     * @param authorization токе авторизации\r\n     * @param cityName название города\r\n     * @param eventName id и символьное название мероприятия\r\n     * @param date дата для поиска\r\n     * @return полная информация мероприятия\r\n     */\r\n    @Override\r\n    public PublicFullInfoEvent getFullInfoEvent(String authorization, String cityName, String eventName, Date date) throws EntityNotFoundException {\r\n        log.trace(\"EventServiceImpl.getFullInfoEvent - cityName {}, event {}, date {}\", cityName, eventName, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n\r\n        /**  Проверка на пользователя*/\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n\r\n            favoriteSet.addAll(client.getEventSet());\r\n        }\r\n\r\n        String[] eventStringName = eventName.split(\"-\", 2);\r\n\r\n        if (!Pattern.compile(\"^\\\\d+$\").matcher(eventStringName[0]).matches() &&\r\n                !Pattern.compile(\"^[A-Za-z0-9._%+@-]+$\").matcher(eventStringName[1]).matches()\r\n        ) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Event error\", \"The event line was entered incorrectly!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        Event event = eventRepository.findFirstByIdAndSymbolicName(Long.valueOf(eventStringName[0]), eventStringName[1]);\r\n\r\n        if (event == null) {\r\n            throw new EntityNotFoundException(\"There is no such event!\");\r\n        }\r\n\r\n        ArrayList<MassiveSessionEvent> massiveSessionEvents = new ArrayList<>();\r\n\r\n        ArrayList<Session> sessions = sessionService.getSessionsByEvent(event, city, date);\r\n\r\n        if (!sessions.isEmpty()) {\r\n            ArrayList<Place> places = new ArrayList<>();\r\n            ArrayList<PublicSession> publicSessions = new ArrayList<>();\r\n\r\n            Session lastSession = sessions.get(sessions.size() - 1);\r\n\r\n            sessions.forEach(session -> {\r\n                PublicSession publicSession = new PublicSession(\r\n                        session.getId(),\r\n                        session.getPrice(),\r\n                        session.getStartTime().toLocalDateTime(),\r\n                        (session.getOnSales() != 0) && (!LocalDateTime.now().isAfter(session.getStartTime().toLocalDateTime()))\r\n                );\r\n\r\n                if (lastSession == session) {\r\n                    publicSessions.add(\r\n                            publicSession\r\n                    );\r\n\r\n                    massiveSessionEvents.add(\r\n                            new MassiveSessionEvent(\r\n                                    session.getHall().getPlace().getPlaceName(),\r\n                                    session.getHall().getPlace().getAddress(),\r\n                                    publicSessions.toArray(PublicSession[]::new)\r\n                            )\r\n                    );\r\n                } else if (!places.contains(session.getHall().getPlace())) {\r\n                    if (!publicSessions.isEmpty()) {\r\n                        massiveSessionEvents.add(\r\n                                new MassiveSessionEvent(\r\n                                        places.get(places.size() - 1).getPlaceName(),\r\n                                        places.get(places.size() - 1).getAddress(),\r\n                                        publicSessions.toArray(PublicSession[]::new)\r\n                                )\r\n                        );\r\n\r\n                        publicSessions.clear();\r\n                    }\r\n\r\n                    places.add(session.getHall().getPlace());\r\n                }\r\n\r\n                publicSessions.add(publicSession);\r\n            });\r\n        }\r\n\r\n        ArrayList<String> genres = new ArrayList<>();\r\n        ArrayList<String> actors = new ArrayList<>();\r\n        ArrayList<String> tags = new ArrayList<>();\r\n\r\n        event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n        event.getEventAdditionalInformation().getActorSet().forEach(actor -> actors.add(actor.getName()));\r\n        event.getEventAdditionalInformation().getTagSet().forEach(tag -> tags.add(tag.getName()));\r\n\r\n        PublicFullInfoEvent publicSession = new PublicFullInfoEvent(\r\n                event.getId(),\r\n                event.getEventBasicInformation().getName_rus(),\r\n                event.getEventBasicInformation().getSymbolicName(),\r\n                event.getEventWebWidget().getDescription(),\r\n                event.getDuration(),\r\n                event.getRating(),\r\n                event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                genres.toArray(String[]::new),\r\n                event.getEventBasicInformation().getPushkin(),\r\n                event.getEventBasicInformation().getImg(),\r\n                event.getEventBasicInformation().getTypeEventId().getType(),\r\n                event.getEventAdditionalInformation().getWriterOrArtist(),\r\n                actors.toArray(String[]::new),\r\n                tags.toArray(String[]::new),\r\n                authorization == null ? null : favoriteSet.contains(event),\r\n                massiveSessionEvents.toArray(MassiveSessionEvent[]::new)\r\n        );\r\n\r\n        return publicSession;\r\n    }\r\n\r\n    /**\r\n     * Метод получения кртакой информации о мероприятиях подходящих под указанный возраст\r\n     * @param cityName название города\r\n     * @param age возраст клиента\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getEventsByCityAndAgeLimit(String cityName, int age, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, age {}, offset {}, date {}\", cityName, age, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя */\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n            favoriteSet.addAll(client.getEventSet());\r\n\r\n        }\r\n\r\n        Set<Event> events = sessionService.getMassiveEventByCityAndAgeLimit(city, age, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /**\r\n     * Метод получения кртакой информации о мероприятиях подходящих под указанный тип\r\n     * @param cityName название города\r\n     * @param type тип мероприятия\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getEventsByCityAndType(String cityName, String type, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, type {}, offset {}, date {}\", cityName, type, offset, date);\r\n        Set<Event> eventSet = new HashSet<>();\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя */\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n            favoriteSet.addAll(client.getEventSet());\r\n\r\n        }\r\n\r\n        String[] citys = cityName.split(\", \");\r\n        String[] types = type.split(\", \");\r\n\r\n        // Преобразование в Set\r\n        Set<City> citySet = new HashSet<>();\r\n        for(String c: citys) {\r\n            City city = cityService.getCityByNameEng(c);\r\n            citySet.add(city);\r\n        }\r\n\r\n        Set<String> typeSet = new HashSet<>();\r\n        for(String t: types) {\r\n            typeSet.add(t);\r\n        }\r\n\r\n        citySet.forEach(c -> {\r\n            typeSet.forEach(t -> {\r\n                eventSet.addAll(sessionService.getMassiveEventByCityAndType(c, t, offset, date));\r\n            });\r\n        });\r\n\r\n        eventSet.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n\r\n    /**\r\n     * Метод получения мероприятия по городу и жанру\r\n     * @param cityName название города\r\n     * @param Genre тип мероприятия\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, genre {}, offset {}, date {}\", cityName, Genre, offset, date);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n        Set<Event> eventSet = new HashSet<>();\r\n\r\n        //  Проверка на пользователя\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n            favoriteSet.addAll(client.getEventSet());\r\n\r\n        }\r\n\r\n        String[] citys = cityName.split(\", \");\r\n        String[] genres = Genre.split(\", \");\r\n\r\n        // Преобразование в Set\r\n        Set<City> citySet = new HashSet<>();\r\n        for(String c: citys) {\r\n            City city = cityService.getCityByNameEng(c);\r\n            citySet.add(city);\r\n        }\r\n        Set<Genre> genreSet = new HashSet<>();\r\n        for(String g: genres) {\r\n            Genre genre = genreService.getGenreOfName(g);\r\n            genreSet.add(genre);\r\n        }\r\n\r\n        citySet.forEach(c -> {\r\n            genreSet.forEach(g -> {\r\n                eventSet.addAll(sessionService.getMassiveEventByCityAndGenre(c, g, offset, date));\r\n            });\r\n        });\r\n\r\n        eventSet.forEach(event -> {\r\n            Set<String> Genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> Genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            Genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/EventServiceImpl.java b/src/main/java/biletka/main/service/Impl/EventServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/EventServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/EventServiceImpl.java	
@@ -46,6 +46,7 @@
     private final GenreService genreService;
     @Lazy
     private final SessionService sessionService;
+    private final RatingService ratingService;
 
     /**
      * Метод создания и добавления мероприятия в бд
@@ -94,6 +95,7 @@
             throw new InvalidDataException(errorMessages);
         }
 
+        System.out.println(organization.getId());
         /** Создание дочерних элементов */
         EventBasicInformation eventBasicInformation = eventBasicInformationService.createEventBasic(eventCreateRequest.eventBasicRequest(), file.getOriginalFilename());
         EventAdditionalInformation eventAdditionalInformation = eventAdditionalInformationService.createEventAdditional(eventCreateRequest.eventAdditional());
@@ -110,12 +112,12 @@
         );
 
         eventRepository.saveAndFlush(eventNew);
-
+        System.out.println(organization.getId());
         /** Добавление мероприятия к организации */
         organizationService.addEventAdmin(organization, eventNew);
 
         /** Сохранение файла */
-        fileUtils.fileUpload(file, "event/" + eventNew.getId() + "-" + eventNew.getEventBasicInformation().getSymbolicName() + "." + typeFile);
+        fileUtils.fileUpload(file, eventNew.getId() + "-" + eventNew.getEventBasicInformation().getImg() + "." + typeFile);
 
         return new MessageCreateResponse(
                 "The event '" + eventNew.getEventBasicInformation().getName() + "' of the '" + eventNew.getEventBasicInformation().getTypeEventId().getType() + "' type has been successfully created!"
@@ -148,7 +150,7 @@
             throw new EntityNotFoundException("The event not found!");
         }
 
-        return fileUtils.getFileEvent(event.getEventBasicInformation().getImg());
+        return fileUtils.getFileEvent(event.getId() + "-" + event.getEventBasicInformation().getImg());
     }
 
     /**
@@ -200,7 +202,8 @@
                             genres.toArray(String[]::new),
                             event.getEventBasicInformation().getImg(),
                             event.getEventBasicInformation().getTypeEventId().getType(),
-                            authorization == null ? null : favoriteSet.contains(event)
+                            authorization == null ? null : favoriteSet.contains(event),
+                            event.getEventWebWidget().getDescription()
                     )
             );
         });
@@ -223,6 +226,7 @@
         Set<Event> favoriteSet = new HashSet<>();
         ArrayList<PublicEvent> publicEvents = new ArrayList<>();
 
+        System.out.println(1);
         /**  Проверка на пользователя*/
         if (authorization != null) {
             String userEmail = jwtTokenUtils.getUsernameFromToken(
@@ -240,7 +244,8 @@
             favoriteSet.addAll(client.getEventSet());
         }
 
-        Set<Event> events = sessionService.getMassiveAnnouncementByCityLimit(city, offset, date);
+        Set<Event> events = eventRepository.getMassiveAnnouncementByLimit(new Timestamp(date.getTime() - 1000000000));
+//        events.addAll(eventRepository.getMassiveAnnouncementByLimit(new Timestamp(date.getTime() - 1000000000)));
 
         events.forEach(event -> {
             Set<String> genres = new HashSet<>();
@@ -256,7 +261,8 @@
                             genres.toArray(String[]::new),
                             event.getEventBasicInformation().getImg(),
                             event.getEventBasicInformation().getTypeEventId().getType(),
-                            authorization == null ? null : favoriteSet.contains(event)
+                            authorization == null ? null : favoriteSet.contains(event),
+                            event.getEventWebWidget().getDescription()
                     )
             );
         });
@@ -370,7 +376,7 @@
         event.getEventAdditionalInformation().getActorSet().forEach(actor -> actors.add(actor.getName()));
         event.getEventAdditionalInformation().getTagSet().forEach(tag -> tags.add(tag.getName()));
 
-        PublicFullInfoEvent publicSession = new PublicFullInfoEvent(
+        return new PublicFullInfoEvent(
                 event.getId(),
                 event.getEventBasicInformation().getName_rus(),
                 event.getEventBasicInformation().getSymbolicName(),
@@ -388,8 +394,50 @@
                 authorization == null ? null : favoriteSet.contains(event),
                 massiveSessionEvents.toArray(MassiveSessionEvent[]::new)
         );
+    }
+
+    /**
+     * Метод получения мероприятия по id и символьному названию
+     * @param eventSymbolic id и символьное название
+     * @return мероприятие
+     */
+    @Override
+    public Event getEventByIdAndSymbolic(String eventSymbolic) {
+        log.trace("EventServiceImpl.getEventByIdAndSymbolic - eventSymbolic {}", eventSymbolic);
+
+        String[] eventStringName = eventSymbolic.split("-", 2);
+
+        if (!Pattern.compile("^\\d+$").matcher(eventStringName[0]).matches() &&
+                !Pattern.compile("^[A-Za-z0-9._%+@-]+$").matcher(eventStringName[1]).matches()
+        ) {
+            List<ErrorMessage> errorMessages = new ArrayList<>();
+            errorMessages.add(new ErrorMessage("Event error", "The event line was entered incorrectly!"));
+            throw new InvalidDataException(errorMessages);
+        }
 
-        return publicSession;
+        Event event = eventRepository.findFirstByIdAndSymbolicName(Long.valueOf(eventStringName[0]), eventStringName[1]);
+
+        if (event == null) {
+            throw new EntityNotFoundException("There is no such event!");
+        }
+
+        return event;
+    }
+
+    /**
+     * Метод изменения рейтинга мероприятия
+     * @param event мероприятие
+     * @param rating рейтинг пользователя
+     */
+    @Override
+    public void putRatingEvent(Event event, Double rating) {
+        log.trace("EventServiceImpl.putRatingEvent - event {}", event);
+        Double totalRating = ratingService.getTotalRatingByEvent(event);
+
+        event.setRating(
+                (event.getRating() + rating) / totalRating
+        );
+        eventRepository.save(event);
     }
 
     /**
Index: src/main/java/biletka/main/controller/OrganizationController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.controller;\r\n\r\n\r\nimport biletka.main.dto.response.OrganizationResponse;\r\nimport biletka.main.dto.response.TotalSession.TotalSession;\r\nimport biletka.main.service.OrganizationService;\r\nimport io.swagger.v3.oas.annotations.Operation;\r\nimport io.swagger.v3.oas.annotations.Parameter;\r\nimport io.swagger.v3.oas.annotations.tags.Tag;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n@Slf4j\r\n@RestController\r\n@RequestMapping(\"/organization\")\r\n@RequiredArgsConstructor\r\n@Tag(name = \"Контроллер организация\", description = \"Всё, что связано с организациями\")\r\npublic class OrganizationController {\r\n    private final OrganizationService organizationService;\r\n\r\n    @Operation(\r\n            summary = \"Получение организации\",\r\n            description = \"Позволяет получить организацию по токену\"\r\n    )\r\n    @GetMapping\r\n    public ResponseEntity<OrganizationResponse> getOrganization(@Parameter(description = \"токен пользователя\") @RequestHeader(\"Authorization\") String authorization){\r\n        System.out.println(organizationService.getOrganization(authorization));\r\n        return ResponseEntity.status(HttpStatus.OK).body(organizationService.getOrganization(authorization));\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод количества сеансов на день\",\r\n            description = \"Вывод количества сеансов на день по площадками\"\r\n    )\r\n    @GetMapping(\"/session_sum\")\r\n    public ResponseEntity<TotalSession> getTotalSessionByOrganization(@Parameter(description = \"токен пользователя\") @RequestHeader(\"Authorization\") String authorization){\r\n        log.trace(\"OrganizationController.getTotalSessionByOrganization / - authorization {}\", authorization);\r\n        return ResponseEntity.status(HttpStatus.OK).body(organizationService.getSessionsByOrganization(authorization));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/controller/OrganizationController.java b/src/main/java/biletka/main/controller/OrganizationController.java
--- a/src/main/java/biletka/main/controller/OrganizationController.java	
+++ b/src/main/java/biletka/main/controller/OrganizationController.java	
@@ -1,15 +1,24 @@
 package biletka.main.controller;
 
+<<<<<<< HEAD
 
 import biletka.main.dto.response.OrganizationResponse;
 import biletka.main.dto.response.TotalSession.TotalSession;
+=======
+import biletka.main.dto.response.EventsOrganization;
+import biletka.main.dto.response.MassivePlacesAndHalls;
+import biletka.main.dto.response.PlacesOrganization;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 import biletka.main.service.OrganizationService;
 import io.swagger.v3.oas.annotations.Operation;
 import io.swagger.v3.oas.annotations.Parameter;
 import io.swagger.v3.oas.annotations.tags.Tag;
 import lombok.RequiredArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
+<<<<<<< HEAD
 import org.springframework.http.HttpStatus;
+=======
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 import org.springframework.http.ResponseEntity;
 import org.springframework.web.bind.annotation.*;
 
@@ -17,11 +26,17 @@
 @RestController
 @RequestMapping("/organization")
 @RequiredArgsConstructor
+<<<<<<< HEAD
 @Tag(name = "Контроллер организация", description = "Всё, что связано с организациями")
+=======
+@Tag(name = "Контроллер ивентов", description = "Всё, что связано с ивентами")
+@CrossOrigin
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 public class OrganizationController {
     private final OrganizationService organizationService;
 
     @Operation(
+<<<<<<< HEAD
             summary = "Получение организации",
             description = "Позволяет получить организацию по токену"
     )
@@ -39,5 +54,37 @@
     public ResponseEntity<TotalSession> getTotalSessionByOrganization(@Parameter(description = "токен пользователя") @RequestHeader("Authorization") String authorization){
         log.trace("OrganizationController.getTotalSessionByOrganization / - authorization {}", authorization);
         return ResponseEntity.status(HttpStatus.OK).body(organizationService.getSessionsByOrganization(authorization));
+=======
+            summary = "Вывод мероприятий организации",
+            description = "Позволяет вывести мероприятии у организации и общее их количество"
+    )
+    @GetMapping("/events")
+    public ResponseEntity<EventsOrganization> getEventOrganization(@Parameter(description = "токен пользователя") @RequestHeader(value = "Authorization") String authorization) {
+        log.trace("OrganizationController.getEventOrganization /event - authorization {}", authorization);
+        EventsOrganization eventsOrganization = organizationService.getEventsOrganization(authorization);
+        return ResponseEntity.ok(eventsOrganization);
+    }
+
+    @Operation(
+            summary = "Вывод площадок организации",
+            description = "Позволяет вывести площадки у организации и количество залов"
+    )
+    @GetMapping("/places")
+    public ResponseEntity<PlacesOrganization> getPlaceOrganization(@Parameter(description = "токен пользователя") @RequestHeader(value = "Authorization") String authorization) {
+        log.trace("OrganizationController.getPlaceOrganization /place - authorization {}", authorization);
+        PlacesOrganization placesOrganization = organizationService.getPlacesOrganization(authorization);
+        return ResponseEntity.ok(placesOrganization);
+    }
+
+    @Operation(
+            summary = "Вывод залов по площадкам организации",
+            description = "Позволяет вывести залы по площадкам организации"
+    )
+    @GetMapping("/halls")
+    public ResponseEntity<MassivePlacesAndHalls> getHallOrganization(@Parameter(description = "токен пользователя") @RequestHeader(value = "Authorization") String authorization) {
+        log.trace("OrganizationController.getHallOrganization /place - authorization {}", authorization);
+        MassivePlacesAndHalls massivePlacesAndHalls = organizationService.getPlacesAndSession(authorization);
+        return ResponseEntity.ok(massivePlacesAndHalls);
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
     }
 }
Index: src/main/java/biletka/main/service/Impl/SessionServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.SessionCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.response.TotalSession.EventsByPlace;\r\nimport biletka.main.dto.response.TotalSession.SessionResponse;\r\nimport biletka.main.entity.*;\r\nimport biletka.main.entity.Event;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.SessionRepository;\r\nimport biletka.main.service.*;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.sql.Timestamp;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\nimport java.time.ZoneId;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\n@Service\r\n@Slf4j\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\npublic class SessionServiceImpl implements SessionService {\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final SessionRepository sessionRepository;\r\n\r\n    private final UserService userService;\r\n    private final OrganizationService organizationService;\r\n    @Lazy\r\n    private final EventService eventService;\r\n    private final HallService hallService;\r\n    private final TypeOfMovieService typeOfMovieService;\r\n\r\n    /**\r\n     * Метод создания и сохранения сеанса мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param sessionCreateRequest информация о сеансе\r\n     * @return о успешном создании сеанса\r\n     */\r\n    @Override\r\n    public MessageCreateResponse sessionCreate(String authorization, SessionCreateRequest sessionCreateRequest) {\r\n        log.trace(\"SessionServiceImpl.sessionCreate - authorization {}, sessionCreateRequest {}\", authorization, sessionCreateRequest);\r\n\r\n        /**  Проверка на организацию пользователя*/\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = organizationService.getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n\r\n        /** Проврека мероприятия на существование */\r\n        Event event = eventService.getEventById(sessionCreateRequest.eventId());\r\n\r\n        if (event == null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Event error\", \"The event does not exist!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Проврека зала на существование */\r\n        Hall hall = hallService.getHallById(sessionCreateRequest.hallId());\r\n\r\n\r\n        if (hall == null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Hall error\", \"The hall does not exist!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Проврека времени */\r\n        LocalDateTime start = sessionCreateRequest.startTime();\r\n        LocalDateTime finish = start.plusHours(Long.parseLong(event.getDuration().split(\":\")[0]))\r\n                .plusMinutes(Long.parseLong(event.getDuration().split(\":\")[1]));\r\n\r\n        if (LocalDateTime.now().isAfter(start)) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Start time error\", \"The date and time of the start of the event must be in the future!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Получения типа сеанса */\r\n        TypeOfMovie typeOfMovie = typeOfMovieService.getTypeByName(sessionCreateRequest.typeOfMovie());\r\n\r\n        /** Проврерка на существование сеанса */\r\n        Session[] sessions = sessionRepository.findSessionsByInfo(Timestamp.valueOf(sessionCreateRequest.startTime()), Timestamp.valueOf(finish), hall.getId());\r\n\r\n        if (sessions.length != 0) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Session error\", \"It is impossible to create a session, because the hall does not exist, or it is occupied!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Сохранение сеанса */\r\n        Session session = new Session(\r\n                0,\r\n                hall.getNumberOfSeats(),\r\n                Timestamp.valueOf(start),\r\n                Timestamp.valueOf(finish),\r\n                0,\r\n                sessionCreateRequest.price(),\r\n                true,\r\n                event,\r\n                hall,\r\n                typeOfMovie\r\n        );\r\n\r\n        sessionRepository.saveAndFlush(session);\r\n\r\n        return new MessageCreateResponse(\r\n                \"The session '\" + event.getEventBasicInformation().getName() +\"' in the hall '\" + hall.getHallName() + \"' has been successfully created!\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public Set<Event> getMassiveEventByCityLimit(City city, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityLimit - city {}, offset {}\", city, offset);\r\n        return sessionRepository.findAllEventByCity(city, offset, new Timestamp(date.getTime()));\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам и дате создания мероприятия\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public Set<Event> getMassiveAnnouncementByCityLimit(City city, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveAnnouncementByCityLimit - city {}, offset {}\", city, offset);\r\n        return sessionRepository.findAllEventAdvertisementByCity(city, offset, new Timestamp(date.getTime()), new Timestamp(date.getTime() - 1000000000));\r\n    }\r\n\r\n    /**\r\n     * Метод получения сеансов мероприятия по городу и дате\r\n     * @param event мероприятие\r\n     * @param city город\r\n     * @param date дата для поиска\r\n     * @return массив сеансов\r\n     */\r\n    @Override\r\n    public ArrayList<Session> getSessionsByEvent(Event event, City city, Date date) {\r\n        log.trace(\"SessionServiceImpl.getSessionsByEvent - event {}, city {}, date {}\", event, city, date);\r\n        return sessionRepository.findAllSessionByEventAndCity(\r\n                event,\r\n                city,\r\n                Timestamp.valueOf(date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate().atStartOfDay()),\r\n                Timestamp.valueOf(date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate().atTime(LocalTime.MAX)));\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по возрасту\r\n     * @param city город\r\n     * @param age возраст\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n     @Override\r\n    public Set<Event> getMassiveEventByCityAndAgeLimit(City city, int age, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityLimit - city {}, age {}, offset {}\", city, age, offset);\r\n        return sessionRepository.findAllEventByCityAndAge(city, age, offset, new Timestamp(date.getTime()));\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по городу и типу\r\n     * @param city город\r\n     * @param type тип мероприятия\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public Set<Event> getMassiveEventByCityAndType(City city, String type, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityAndGenre - city {}, type {}, offset {}\", city, type, offset);\r\n        return sessionRepository.findAllEventByCityAndType(city, type, offset, new Timestamp(date.getTime()));\r\n    }\r\n\r\n\r\n    /**\r\n     * Метод получения мероприятий по\r\n     * @param city город\r\n     * @param genre жанр\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public Set<Event> getMassiveEventByCityAndGenre(City city, Genre genre, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityAndGenre - city {}, genre {}, offset {}\", city, genre, offset);\r\n        return sessionRepository.findAllEventByCityAndGenre(city, genre, offset, new Timestamp(date.getTime()));\r\n    }\r\n\r\n\r\n    /**\r\n     * Метод получения сеансов на площадке\r\n     * @param place площадка\r\n     * @return количество сеансов\r\n     */\r\n    @Override\r\n    public EventsByPlace[] getSessionByPlaceAndEvent(Place place) {\r\n        log.trace(\"SessionServiceImpl.getSessionByPlaceAndEvent - place {}\", place);\r\n\r\n        ArrayList<EventsByPlace> eventsByPlaces = new ArrayList<>();\r\n\r\n        ArrayList<SessionResponse> sessionResponses = new ArrayList<>();\r\n\r\n        Set<Event> events = sessionRepository.findEventsByPlace(place);\r\n        events.forEach(event -> {\r\n            Set<Session> sessions = sessionRepository.findAllSessionByPlaceAndEvent(place, event);\r\n            sessions.forEach(session -> {\r\n                sessionResponses.add(\r\n                        new SessionResponse(\r\n                                session.getSales(),\r\n                                session.getOnSales(),\r\n                                session.getStartTime(),\r\n                                session.getFinishTime(),\r\n                                session.getNumberOfViews(),\r\n                                session.getPrice(),\r\n                                session.getStatus()\r\n                        )\r\n                );\r\n            });\r\n            eventsByPlaces.add(\r\n                    new EventsByPlace(\r\n                            event.getEventBasicInformation().getName(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            sessionResponses.toArray(SessionResponse[]::new)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return eventsByPlaces.toArray(EventsByPlace[]::new);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java b/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java	
@@ -25,6 +25,7 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
 
 @Service
 @Slf4j
@@ -56,7 +57,6 @@
         );
 
         Users user = userService.getUserOrganizationByEmail(userEmail);
-
         if (user == null) {
             throw new EntityNotFoundException("A broken token!");
         }
@@ -76,7 +76,7 @@
             errorMessages.add(new ErrorMessage("Event error", "The event does not exist!"));
             throw new InvalidDataException(errorMessages);
         }
-
+        System.out.println(1);
         /** Проврека зала на существование */
         Hall hall = hallService.getHallById(sessionCreateRequest.hallId());
 
@@ -86,6 +86,7 @@
             errorMessages.add(new ErrorMessage("Hall error", "The hall does not exist!"));
             throw new InvalidDataException(errorMessages);
         }
+        System.out.println(2);
 
         /** Проврека времени */
         LocalDateTime start = sessionCreateRequest.startTime();
@@ -97,19 +98,23 @@
             errorMessages.add(new ErrorMessage("Start time error", "The date and time of the start of the event must be in the future!"));
             throw new InvalidDataException(errorMessages);
         }
+        System.out.println(3);
 
         /** Получения типа сеанса */
         TypeOfMovie typeOfMovie = typeOfMovieService.getTypeByName(sessionCreateRequest.typeOfMovie());
 
+        System.out.println(4);
         /** Проврерка на существование сеанса */
         Session[] sessions = sessionRepository.findSessionsByInfo(Timestamp.valueOf(sessionCreateRequest.startTime()), Timestamp.valueOf(finish), hall.getId());
 
+        System.out.println(5);
         if (sessions.length != 0) {
             List<ErrorMessage> errorMessages = new ArrayList<>();
             errorMessages.add(new ErrorMessage("Session error", "It is impossible to create a session, because the hall does not exist, or it is occupied!"));
             throw new InvalidDataException(errorMessages);
         }
 
+        System.out.println(6);
         /** Сохранение сеанса */
         Session session = new Session(
                 0,
@@ -126,6 +131,7 @@
 
         sessionRepository.saveAndFlush(session);
 
+        System.out.println(8);
         return new MessageCreateResponse(
                 "The session '" + event.getEventBasicInformation().getName() +"' in the hall '" + hall.getHallName() + "' has been successfully created!"
         );
@@ -175,6 +181,7 @@
     }
 
     /**
+<<<<<<< HEAD
      * Метод получения уникальных мероприятий по возрасту
      * @param city город
      * @param age возраст
@@ -257,5 +264,22 @@
         });
 
         return eventsByPlaces.toArray(EventsByPlace[]::new);
+=======
+     * Получение количества сеансов мероприятия организации
+     * @param event мероприятие
+     * @param placeSet площадки
+     * @return количество сеансов
+     */
+    @Override
+    public Integer getTotalByEventAndPlaces(Event event, Set<Place> placeSet) {
+        log.trace("SessionServiceImpl.getTotalByEventAndPlaces - event {}, placeSet {}", event, placeSet);
+        AtomicReference<Integer> total = new AtomicReference<>(0);
+
+        placeSet.forEach(place -> {
+            total.updateAndGet(v -> v + sessionRepository.findSumByEventAndPlace(event, place));
+        });
+
+        return total.get();
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
     }
 }
Index: src/main/java/biletka/main/service/SessionService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.dto.request.SessionCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.response.TotalSession.EventsByPlace;\r\nimport biletka.main.dto.response.TotalSession.SessionResponse;\r\nimport biletka.main.entity.*;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.Set;\r\n\r\n@Service\r\npublic interface SessionService {\r\n    /**\r\n     * Метод создания и сохранения сеанса мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param sessionCreateRequest информация о сеансе\r\n     * @return о успешном создании сеанса\r\n     */\r\n    MessageCreateResponse sessionCreate(String authorization, SessionCreateRequest sessionCreateRequest);\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveEventByCityLimit(City city, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам и дате создания мероприятия\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveAnnouncementByCityLimit(City city, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения сеансов мероприятия по городу и дате\r\n     * @param event мероприятие\r\n     * @param city город\r\n     * @param date дата для поиска\r\n     * @return массив сеансов\r\n     */\r\n    ArrayList<Session> getSessionsByEvent(Event event, City city, Date date);\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по возрасту\r\n     * @param city город\r\n     * @param age возраст\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveEventByCityAndAgeLimit(City city, int age, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по городу и типу\r\n     * @param city город\r\n     * @param type тип мероприятия\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveEventByCityAndType(City city, String type, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения мероприятий по\r\n     * @param city город\r\n     * @param genre жанр\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveEventByCityAndGenre(City city, Genre genre, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения сеансов на площадке\r\n     * @param place площадка\r\n     * @return количество сеансов\r\n     */\r\n    EventsByPlace[] getSessionByPlaceAndEvent(Place place);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/SessionService.java b/src/main/java/biletka/main/service/SessionService.java
--- a/src/main/java/biletka/main/service/SessionService.java	
+++ b/src/main/java/biletka/main/service/SessionService.java	
@@ -2,9 +2,16 @@
 
 import biletka.main.dto.request.SessionCreateRequest;
 import biletka.main.dto.response.MessageCreateResponse;
+<<<<<<< HEAD
 import biletka.main.dto.response.TotalSession.EventsByPlace;
 import biletka.main.dto.response.TotalSession.SessionResponse;
 import biletka.main.entity.*;
+=======
+import biletka.main.entity.City;
+import biletka.main.entity.Event;
+import biletka.main.entity.Place;
+import biletka.main.entity.Session;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 import org.springframework.stereotype.Service;
 
 import java.util.ArrayList;
@@ -49,6 +56,7 @@
     ArrayList<Session> getSessionsByEvent(Event event, City city, Date date);
 
     /**
+<<<<<<< HEAD
      * Метод получения уникальных мероприятий по возрасту
      * @param city город
      * @param age возраст
@@ -84,4 +92,12 @@
      * @return количество сеансов
      */
     EventsByPlace[] getSessionByPlaceAndEvent(Place place);
+=======
+     * Получение количества сеансов мероприятия организации
+     * @param event мероприятие
+     * @param placeSet площадки
+     * @return количество сеансов мероприятия
+     */
+    Integer getTotalByEventAndPlaces(Event event, Set<Place> placeSet);
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 }
Index: src/main/java/biletka/main/repository/SessionRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.repository;\r\n\r\nimport biletka.main.entity.*;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\n\r\nimport java.sql.Timestamp;\r\nimport java.util.ArrayList;\r\nimport java.util.Set;\r\n\r\npublic interface SessionRepository extends JpaRepository<Session, Long> {\r\n\r\n    @Query(value = \"SELECT * FROM session \" +\r\n            \"WHERE session.hall_id = :id \" +\r\n            \"AND (session.start_time BETWEEN :start AND :finish \" +\r\n            \"OR session.finish_time BETWEEN :start AND :finish) \", nativeQuery = true)\r\n    Session[] findSessionsByInfo(Timestamp start, Timestamp finish, Long id);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCity(City city, Integer offset, Timestamp nowDate);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"AND s.event.createdAt >= :createDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventAdvertisementByCity(City city, Integer offset, Timestamp nowDate, Timestamp createDate);\r\n\r\n    @Query(\"SELECT s FROM Session s \" +\r\n            \"WHERE s.event = :event \" +\r\n            \"AND s.hall.place.city = :city \" +\r\n            \"AND s.startTime BETWEEN :startDay AND :finishDay \" +\r\n            \"ORDER BY s.hall.place, s.startTime \")\r\n    ArrayList<Session> findAllSessionByEventAndCity(Event event, City city, Timestamp startDay, Timestamp finishDay);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.event.eventBasicInformation.ageRatingId.limitation <= :age \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCityAndAge (City city, int age, Integer offset, Timestamp nowDate);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.event.eventBasicInformation.typeEventId.type = :type \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCityAndType (City city, String type, Integer offset, Timestamp nowDate);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND EXISTS(SELECT g FROM s.event.eventBasicInformation.genres g \" +\r\n            \"WHERE g = :genre) \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCityAndGenre (City city, Genre genre, Integer offset, Timestamp nowDate);\r\n\r\n    @Query(\"SELECT s FROM Session s \" +\r\n    \"WHERE s.hall.place = :place \" +\r\n    \"AND s.event = :event \")\r\n    Set<Session> findAllSessionByPlaceAndEvent(Place place, Event event);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n    \"WHERE s.hall.place = :place \")\r\n    Set<Event> findEventsByPlace(Place place);\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/repository/SessionRepository.java b/src/main/java/biletka/main/repository/SessionRepository.java
--- a/src/main/java/biletka/main/repository/SessionRepository.java	
+++ b/src/main/java/biletka/main/repository/SessionRepository.java	
@@ -1,6 +1,13 @@
 package biletka.main.repository;
 
+<<<<<<< HEAD
 import biletka.main.entity.*;
+=======
+import biletka.main.entity.City;
+import biletka.main.entity.Event;
+import biletka.main.entity.Place;
+import biletka.main.entity.Session;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Query;
 
@@ -38,6 +45,7 @@
             "ORDER BY s.hall.place, s.startTime ")
     ArrayList<Session> findAllSessionByEventAndCity(Event event, City city, Timestamp startDay, Timestamp finishDay);
 
+<<<<<<< HEAD
     @Query("SELECT s.event FROM Session s " +
             "WHERE s.hall.place.city = :city " +
             "AND s.event.eventBasicInformation.ageRatingId.limitation <= :age " +
@@ -73,3 +81,10 @@
     Set<Event> findEventsByPlace(Place place);
 }
 
+=======
+    @Query("SELECT COUNT(s) FROM Session s " +
+            "WHERE s.event = :event " +
+            "AND s.hall.place = :place")
+    Integer findSumByEventAndPlace(Event event, Place place);
+}
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
Index: src/main/java/biletka/main/service/CityService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.entity.City;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic interface CityService {\r\n    /**\r\n     * Метод получения города по английскому названию\r\n     * @param name название города\r\n     * @return город\r\n     */\r\n    City getCityByNameEng(String name);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/CityService.java b/src/main/java/biletka/main/service/CityService.java
--- a/src/main/java/biletka/main/service/CityService.java	
+++ b/src/main/java/biletka/main/service/CityService.java	
@@ -1,5 +1,6 @@
 package biletka.main.service;
 
+import biletka.main.dto.response.MassiveCityResponse;
 import biletka.main.entity.City;
 import org.springframework.stereotype.Service;
 
@@ -11,4 +12,10 @@
      * @return город
      */
     City getCityByNameEng(String name);
+
+    /**
+     * Метод получения всех городов
+     * @return массив городов
+     */
+    MassiveCityResponse getAllCity();
 }
Index: src/main/java/biletka/main/dto/universal/PublicEvent.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.dto.universal;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\n\r\npublic record PublicEvent(\r\n        @JsonProperty(\"id\")\r\n        Long id,\r\n\r\n        @JsonProperty(\"name_rus\")\r\n        String nameRus,\r\n\r\n        @JsonProperty(\"symbolic_name\")\r\n        String symbolicName,\r\n\r\n        @JsonProperty(\"age_rating\")\r\n        Integer ageRating,\r\n\r\n        @JsonProperty(\"genres\")\r\n        String[] genres,\r\n\r\n        @JsonProperty(\"img\")\r\n        String img,\r\n\r\n        @JsonProperty(\"type_event\")\r\n        String typeEvent,\r\n\r\n        @JsonProperty(\"favorite\")\r\n        Boolean favorite\r\n) {\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/universal/PublicEvent.java b/src/main/java/biletka/main/dto/universal/PublicEvent.java
--- a/src/main/java/biletka/main/dto/universal/PublicEvent.java	
+++ b/src/main/java/biletka/main/dto/universal/PublicEvent.java	
@@ -25,6 +25,9 @@
         String typeEvent,
 
         @JsonProperty("favorite")
-        Boolean favorite
+        Boolean favorite,
+
+        @JsonProperty("description")
+        String description
 ) {
 }
Index: src/main/java/biletka/main/service/Impl/CityServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.entity.City;\r\nimport biletka.main.repository.CityRepository;\r\nimport biletka.main.service.CityService;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class CityServiceImpl implements CityService {\r\n    private final CityRepository cityRepository;\r\n\r\n    /**\r\n     * Метод получения города по английскому названию\r\n     * @param name название города\r\n     * @return город\r\n     */\r\n    @Override\r\n    public City getCityByNameEng(String name) throws EntityNotFoundException {\r\n        City city = cityRepository.findFirstByCityNameEng(name);\r\n\r\n        if (city == null) {\r\n            throw new EntityNotFoundException(\"City not found!\");\r\n        }\r\n\r\n        return city;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/CityServiceImpl.java b/src/main/java/biletka/main/service/Impl/CityServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/CityServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/CityServiceImpl.java	
@@ -1,5 +1,7 @@
 package biletka.main.service.Impl;
 
+import biletka.main.dto.response.CityResponse;
+import biletka.main.dto.response.MassiveCityResponse;
 import biletka.main.entity.City;
 import biletka.main.repository.CityRepository;
 import biletka.main.service.CityService;
@@ -8,6 +10,8 @@
 import lombok.extern.slf4j.Slf4j;
 import org.springframework.stereotype.Service;
 
+import java.util.ArrayList;
+
 @Service
 @RequiredArgsConstructor
 @Slf4j
@@ -21,6 +25,7 @@
      */
     @Override
     public City getCityByNameEng(String name) throws EntityNotFoundException {
+        log.trace("CityServiceImpl.getCityByNameEng - name {}", name);
         City city = cityRepository.findFirstByCityNameEng(name);
 
         if (city == null) {
@@ -29,4 +34,26 @@
 
         return city;
     }
+
+    /**
+     * Метод получения всех городов
+     * @return массив городов
+     */
+    @Override
+    public MassiveCityResponse getAllCity() {
+        log.trace("CityServiceImpl.getAllCity");
+        ArrayList<CityResponse> cityResponseArrayList = new ArrayList<>();
+
+        cityRepository.findAll().forEach(city -> {
+            cityResponseArrayList.add(
+                    new CityResponse(
+                            city.getId(),
+                            city.getCityName(),
+                            city.getCityNameEng()
+                    )
+            );
+        });
+
+        return new MassiveCityResponse(cityResponseArrayList.toArray(CityResponse[]::new));
+    }
 }
Index: src/main/java/biletka/main/service/Impl/GenreServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.entity.Genre;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.GenreRepository;\r\nimport biletka.main.service.GenreService;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class GenreServiceImpl implements GenreService {\r\n    private final GenreRepository genreRepository;\r\n\r\n    /**\r\n     * Метод поиска жанра\r\n     * @param name название жанра\r\n     * @return жанр\r\n     */\r\n    @Override\r\n    public Genre getGenreOfName(String name){\r\n        log.trace(\"GenreServiceImpl.getGenreOfName - name {}\", name);\r\n        return genreRepository.findFirstByName(name);\r\n    }\r\n\r\n    /**\r\n     * Метод создания жанра\r\n     * @param name название жанра\r\n     * @return жанр\r\n     */\r\n    @Override\r\n    public Genre createGenre(String name) {\r\n        log.trace(\"GenreServiceImpl.createGenre - name {}\", name);\r\n        Genre genre = genreRepository.findFirstByName(name);\r\n\r\n        if (genre != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Genre error\", \"This genre already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        Genre genreNew = new Genre(name);\r\n\r\n        genreRepository.saveAndFlush(genreNew);\r\n\r\n        return genreNew;\r\n    }\r\n\r\n    /**\r\n     * Метод Создания нового жанра и сохранения в бд\r\n     * @param name - название жанра\r\n     * @return Созданный жанр\r\n     */\r\n    @Override\r\n    public Genre postNewGenre(String name){\r\n        log.trace(\"GenreService.postNewGenre - name{}\", name);\r\n\r\n        Genre genre = genreRepository.findFirstByName(name);\r\n\r\n        if(genre!= null){\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Post error\", \"This genre already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        Genre newGenre = new Genre(name);\r\n        genreRepository.saveAndFlush(newGenre);\r\n        return newGenre;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/GenreServiceImpl.java b/src/main/java/biletka/main/service/Impl/GenreServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/GenreServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/GenreServiceImpl.java	
@@ -1,5 +1,7 @@
 package biletka.main.service.Impl;
 
+import biletka.main.dto.response.GenreResponse;
+import biletka.main.dto.response.MassiveGenreResponse;
 import biletka.main.entity.Genre;
 import biletka.main.exception.ErrorMessage;
 import biletka.main.exception.InvalidDataException;
@@ -73,5 +75,26 @@
         genreRepository.saveAndFlush(newGenre);
         return newGenre;
     }
+
+    /**
+     * Метод получения всех жанров
+     * @return массив жанров
+     */
+    @Override
+    public MassiveGenreResponse getAllGenre() {
+        log.trace("GenreService.getAllGenre");
+        ArrayList<GenreResponse> genreResponseArrayList = new ArrayList<>();
+
+        genreRepository.findAll().forEach(genre -> {
+            genreResponseArrayList.add(
+                    new GenreResponse(
+                            genre.getId(),
+                            genre.getName()
+                    )
+            );
+        });
+
+        return new MassiveGenreResponse(genreResponseArrayList.toArray(GenreResponse[]::new));
+    }
 }
 
Index: src/main/java/biletka/main/service/GenreService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.entity.Genre;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic interface GenreService {\r\n    /**\r\n     * Метод поиска жанра\r\n     * @param name название жанра\r\n     * @return жанр\r\n     */\r\n    Genre getGenreOfName(String name);\r\n\r\n    /**\r\n     * Метод создания жанра\r\n     * @param name название жанра\r\n     * @return жанр\r\n     */\r\n    Genre createGenre(String name);\r\n\r\n    Genre postNewGenre(String name);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/GenreService.java b/src/main/java/biletka/main/service/GenreService.java
--- a/src/main/java/biletka/main/service/GenreService.java	
+++ b/src/main/java/biletka/main/service/GenreService.java	
@@ -1,5 +1,6 @@
 package biletka.main.service;
 
+import biletka.main.dto.response.MassiveGenreResponse;
 import biletka.main.entity.Genre;
 import org.springframework.stereotype.Service;
 
@@ -20,4 +21,10 @@
     Genre createGenre(String name);
 
     Genre postNewGenre(String name);
+
+    /**
+     * Метод получения всех жанров
+     * @return массив жанров
+     */
+    MassiveGenreResponse getAllGenre();
 }
Index: src/main/java/biletka/main/service/TypeEventService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.entity.TypeEvent;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic interface TypeEventService {\r\n    TypeEvent getTypeEventOfName(String type);\r\n\r\n    /**\r\n     * Метод создания типа мероприятия\r\n     * @param type навзание типа мероприятия\r\n     * @return тип мероприятия\r\n     */\r\n    TypeEvent createTypeEvent(String type);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/TypeEventService.java b/src/main/java/biletka/main/service/TypeEventService.java
--- a/src/main/java/biletka/main/service/TypeEventService.java	
+++ b/src/main/java/biletka/main/service/TypeEventService.java	
@@ -1,5 +1,6 @@
 package biletka.main.service;
 
+import biletka.main.dto.response.MassiveTypeResponse;
 import biletka.main.entity.TypeEvent;
 import org.springframework.stereotype.Service;
 
@@ -13,4 +14,10 @@
      * @return тип мероприятия
      */
     TypeEvent createTypeEvent(String type);
+
+    /**
+     * Метод вывода всех возможных типов мероприятия
+     * @return массив типов
+     */
+    MassiveTypeResponse getAllType();
 }
Index: src/main/java/biletka/main/repository/TypeEventRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.repository;\r\n\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport biletka.main.entity.TypeEvent;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.stereotype.Repository;\r\n\r\n@Repository\r\npublic interface TypeEventRepository extends JpaRepository<TypeEvent, Long>{\r\n    @Query(\"SELECT t FROM TypeEvent t \" +\r\n            \"WHERE t.type = :type\")\r\n    TypeEvent findFirstByType(String type);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/repository/TypeEventRepository.java b/src/main/java/biletka/main/repository/TypeEventRepository.java
--- a/src/main/java/biletka/main/repository/TypeEventRepository.java	
+++ b/src/main/java/biletka/main/repository/TypeEventRepository.java	
@@ -5,6 +5,8 @@
 import org.springframework.data.jpa.repository.Query;
 import org.springframework.stereotype.Repository;
 
+import java.util.List;
+
 @Repository
 public interface TypeEventRepository extends JpaRepository<TypeEvent, Long>{
     @Query("SELECT t FROM TypeEvent t " +
Index: src/main/java/biletka/main/repository/EventRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.repository;\r\n\r\nimport biletka.main.entity.Event;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\n\r\nimport java.util.Set;\r\n\r\npublic interface EventRepository extends JpaRepository<Event, Long> {\r\n    @Query(\"SELECT e FROM Event e \" +\r\n            \"WHERE e.eventBasicInformation.name = :name \" +\r\n            \"AND e.eventBasicInformation.typeEventId.type = :type\")\r\n    Event findFirstByName(String name, String type);\r\n\r\n    @Query(\"SELECT e FROM Event e \" +\r\n            \"WHERE e.id = :id \" +\r\n            \"AND e.eventBasicInformation.symbolicName = :symbolicName\")\r\n    Event findFirstByIdAndSymbolicName(Long id, String symbolicName);\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/repository/EventRepository.java b/src/main/java/biletka/main/repository/EventRepository.java
--- a/src/main/java/biletka/main/repository/EventRepository.java	
+++ b/src/main/java/biletka/main/repository/EventRepository.java	
@@ -4,6 +4,12 @@
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.data.jpa.repository.Query;
 
+<<<<<<< HEAD
+=======
+import java.sql.Timestamp;
+import java.util.Collection;
+import java.util.Date;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 import java.util.Set;
 
 public interface EventRepository extends JpaRepository<Event, Long> {
@@ -17,5 +23,13 @@
             "AND e.eventBasicInformation.symbolicName = :symbolicName")
     Event findFirstByIdAndSymbolicName(Long id, String symbolicName);
 
+<<<<<<< HEAD
 
+=======
+    @Query("SELECT e FROM Event e " +
+            "WHERE e.createdAt >= :createDate " +
+            "ORDER BY e.id " +
+            "LIMIT 6 OFFSET 0")
+    Set<Event> getMassiveAnnouncementByLimit(Timestamp createDate);
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 }
Index: src/main/java/biletka/main/controller/SecurityController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.controller;\r\n\r\nimport biletka.main.dto.request.ActiveClientRequest;\r\nimport biletka.main.dto.request.AuthForm;\r\nimport biletka.main.dto.request.ClientRegistrationRequest;\r\nimport biletka.main.dto.request.OrganizationRegistrationRequest;\r\nimport biletka.main.dto.response.AuthResponse;\r\nimport biletka.main.dto.response.ClientRegistrationResponse;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.service.UserService;\r\nimport io.swagger.v3.oas.annotations.Hidden;\r\nimport io.swagger.v3.oas.annotations.Operation;\r\nimport io.swagger.v3.oas.annotations.Parameter;\r\nimport io.swagger.v3.oas.annotations.tags.Tag;\r\nimport jakarta.mail.MessagingException;\r\nimport jakarta.validation.Valid;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.text.ParseException;\r\n\r\n@Slf4j\r\n@RestController\r\n@RequestMapping(\"/security\")\r\n@RequiredArgsConstructor\r\n@Tag(name = \"Контроллер безопасности\", description = \"Всё, что связано с безопасностью\")\r\npublic class SecurityController {\r\n    private final UserService userService;\r\n    private final AuthenticationManager authenticationManager;\r\n\r\n    @Operation(\r\n            summary = \"Аутентификация пользователя\",\r\n            description = \"Ползволяется пройти аутентификацию и получить jwt\"\r\n    )\r\n    @Hidden\r\n    @PostMapping(\"/auth\")\r\n    public ResponseEntity<AuthResponse> createAuthToken(@Parameter(description = \"Форма авторизации\") @Valid @RequestBody AuthForm authForm) {\r\n        log.trace(\"SecurityController.createAuthToken /auth - authForm {}\", authForm);\r\n        authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(authForm.email(), authForm.password()));\r\n        AuthResponse authResponse = userService.getAuthToken(authForm);\r\n\r\n        return ResponseEntity.ok(authResponse);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Регистрация обычного пользователя\",\r\n            description = \"Позволяет сохранить нового пользователя в базе данных\"\r\n    )\r\n    @PostMapping\r\n    public ResponseEntity<ClientRegistrationResponse> postClientRegistration(@Parameter(description = \"Данные для регистрации нового пользователя\") @Valid @RequestBody ClientRegistrationRequest clientRegistrationRequest) throws ParseException, MessagingException {\r\n        log.trace(\"SecurityController.postClientRegistration / - clientRegistrationRequest {}\", clientRegistrationRequest);\r\n        ClientRegistrationResponse clientRegistrationResponse = userService.postNewUser(clientRegistrationRequest);\r\n\r\n        return ResponseEntity.status(HttpStatus.CREATED).body(clientRegistrationResponse);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Регистрация организации\",\r\n            description = \"Позволяет сохранить новую организацию в базе данных\"\r\n    )\r\n    @PostMapping(\"/organization\")\r\n    public ResponseEntity<MessageCreateResponse> postOrganizationRegistration(@Parameter(description = \"Данные организации\") @Valid @RequestBody OrganizationRegistrationRequest organizationRegistrationRequest) {\r\n        log.trace(\"SecurityController.postOrganizationRegistration /organization - organizationRegistrationRequest {}\", organizationRegistrationRequest);\r\n        MessageCreateResponse messageCreateResponse = userService.postNewOrganization(organizationRegistrationRequest);\r\n\r\n        return ResponseEntity.status(HttpStatus.CREATED).body(messageCreateResponse);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Активация аккаунта\",\r\n            description = \"Позволяет изменить данные пользователя, чтобы он был активирован\"\r\n    )\r\n    @PutMapping(\"/active\")\r\n    public ResponseEntity<ClientRegistrationResponse> putActiveUser(@Parameter(description = \"Данные для активации\") @Valid @RequestBody ActiveClientRequest activeClientRequest) {\r\n        log.trace(\"SecurityController.putActiveUser /active - activeClientRequest {}\", activeClientRequest);\r\n        ClientRegistrationResponse clientRegistrationResponse = userService.putActiveUser(activeClientRequest);\r\n\r\n        return ResponseEntity.accepted().body(clientRegistrationResponse);\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/controller/SecurityController.java b/src/main/java/biletka/main/controller/SecurityController.java
--- a/src/main/java/biletka/main/controller/SecurityController.java	
+++ b/src/main/java/biletka/main/controller/SecurityController.java	
@@ -1,5 +1,6 @@
 package biletka.main.controller;
 
+import biletka.main.Utils.IpAddressUtils;
 import biletka.main.dto.request.ActiveClientRequest;
 import biletka.main.dto.request.AuthForm;
 import biletka.main.dto.request.ClientRegistrationRequest;
@@ -13,6 +14,7 @@
 import io.swagger.v3.oas.annotations.Parameter;
 import io.swagger.v3.oas.annotations.tags.Tag;
 import jakarta.mail.MessagingException;
+import jakarta.servlet.http.HttpServletRequest;
 import jakarta.validation.Valid;
 import lombok.RequiredArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
@@ -32,6 +34,7 @@
 public class SecurityController {
     private final UserService userService;
     private final AuthenticationManager authenticationManager;
+    private final IpAddressUtils ipAddressUtils;
 
     @Operation(
             summary = "Аутентификация пользователя",
@@ -64,10 +67,12 @@
             description = "Позволяет сохранить новую организацию в базе данных"
     )
     @PostMapping("/organization")
-    public ResponseEntity<MessageCreateResponse> postOrganizationRegistration(@Parameter(description = "Данные организации") @Valid @RequestBody OrganizationRegistrationRequest organizationRegistrationRequest) {
+    public ResponseEntity<MessageCreateResponse> postOrganizationRegistration(@Parameter(description = "Данные организации") @Valid @RequestBody OrganizationRegistrationRequest organizationRegistrationRequest,
+                                                                              @Parameter(description = "Тело запроса клиента")HttpServletRequest request,
+                                                                              @Parameter(description = "токен пользователя") @RequestHeader("Authorization") String authorization) {
         log.trace("SecurityController.postOrganizationRegistration /organization - organizationRegistrationRequest {}", organizationRegistrationRequest);
+        ipAddressUtils.checkIpInAdministrator(request, authorization);
         MessageCreateResponse messageCreateResponse = userService.postNewOrganization(organizationRegistrationRequest);
-
         return ResponseEntity.status(HttpStatus.CREATED).body(messageCreateResponse);
     }
 
Index: .idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
--- /dev/null	
+++ b/.idea/.gitignore	
@@ -0,0 +1,3 @@
+# Default ignored files
+/shelf/
+/workspace.xml
Index: .idea/.name
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.name b/.idea/.name
new file mode 100644
--- /dev/null	
+++ b/.idea/.name	
@@ -0,0 +1,1 @@
+main
\ No newline at end of file
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/compiler.xml	
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <annotationProcessing>
+      <profile name="Gradle Imported" enabled="true">
+        <outputRelativeToContentRoot value="true" />
+        <processorPath useClasspath="false">
+          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-configuration-processor/3.2.5/748cf1d49e04e20db1784e88f676657cd030d937/spring-boot-configuration-processor-3.2.5.jar" />
+          <entry name="$USER_HOME$/.gradle/caches/modules-2/files-2.1/org.projectlombok/lombok/1.18.32/17d46b3e205515e1e8efd3ee4d57ce8018914163/lombok-1.18.32.jar" />
+        </processorPath>
+        <module name="main.main" />
+      </profile>
+    </annotationProcessing>
+    <bytecodeTargetLevel target="17" />
+  </component>
+</project>
\ No newline at end of file
Index: src/main/java/biletka/main/controller/advice/ExceptionConveyorHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.controller.advice;\r\n\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.ErrorResponse;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\r\nimport jakarta.persistence.EntityExistsException;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.security.core.AuthenticationException;\r\nimport org.springframework.web.bind.MethodArgumentNotValidException;\r\nimport org.springframework.web.bind.annotation.ControllerAdvice;\r\nimport org.springframework.web.bind.annotation.ExceptionHandler;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\nimport org.springframework.web.bind.annotation.ResponseStatus;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\n\r\n@Slf4j\r\n@ControllerAdvice\r\npublic class ExceptionConveyorHandler {\r\n    @ResponseBody\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    @ExceptionHandler(MethodArgumentNotValidException.class)\r\n    public List<ErrorMessage> onMethodArgumentNotValidException(MethodArgumentNotValidException e) {\r\n        return e.getBindingResult().getFieldErrors().stream()\r\n                .map(error -> new ErrorMessage(error.getField(), error.getDefaultMessage())).toList();\r\n    }\r\n\r\n    @ResponseBody\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    @ExceptionHandler(InvalidDataException.class)\r\n    public List<ErrorMessage> onInvalidDataException(InvalidDataException e) {\r\n        return e.getInvalidFields();\r\n    }\r\n\r\n    @ResponseBody\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    @ExceptionHandler(InvalidFormatException.class)\r\n    public ErrorResponse onInvalidFormatException(InvalidFormatException e) {\r\n        return createResponseException(HttpStatus.BAD_REQUEST, e.getTargetType().toString(), e.getMessage());\r\n    }\r\n\r\n    @ResponseBody\r\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\r\n    @ExceptionHandler(EntityExistsException.class)\r\n    public ErrorResponse onInvalidFormatException(EntityExistsException e) {\r\n        return createResponseException(HttpStatus.BAD_REQUEST, \"Entity already exists\", e.getMessage());\r\n    }\r\n\r\n    @ResponseBody\r\n    @ResponseStatus(HttpStatus.NOT_FOUND)\r\n    @ExceptionHandler(EntityNotFoundException.class)\r\n    public ErrorResponse onInvalidApplicationId(EntityNotFoundException ex) {\r\n        return createResponseException(HttpStatus.NOT_FOUND, \"Entity not found\", ex.getMessage());\r\n    }\r\n\r\n    @ResponseBody\r\n    @ResponseStatus(HttpStatus.UNAUTHORIZED)\r\n    @ExceptionHandler(AuthenticationException.class)\r\n    public ErrorResponse onAuthenticationException(AuthenticationException ex) {\r\n        return createResponseException(HttpStatus.UNAUTHORIZED, \"Uncorrected login or password\", ex.getMessage());\r\n    }\r\n\r\n    private ErrorResponse createResponseException(HttpStatus status, String error, String message) {\r\n        return new ErrorResponse(\r\n                LocalDateTime.now(),\r\n                status.value(),\r\n                error,\r\n                message\r\n        );\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/controller/advice/ExceptionConveyorHandler.java b/src/main/java/biletka/main/controller/advice/ExceptionConveyorHandler.java
--- a/src/main/java/biletka/main/controller/advice/ExceptionConveyorHandler.java	
+++ b/src/main/java/biletka/main/controller/advice/ExceptionConveyorHandler.java	
@@ -14,6 +14,7 @@
 import org.springframework.web.bind.annotation.ExceptionHandler;
 import org.springframework.web.bind.annotation.ResponseBody;
 import org.springframework.web.bind.annotation.ResponseStatus;
+import org.springframework.web.client.HttpClientErrorException.Forbidden;
 
 import java.time.LocalDateTime;
 import java.util.List;
@@ -64,6 +65,13 @@
         return createResponseException(HttpStatus.UNAUTHORIZED, "Uncorrected login or password", ex.getMessage());
     }
 
+    @ResponseBody
+    @ResponseStatus(HttpStatus.FORBIDDEN)
+    @ExceptionHandler(Forbidden.class)
+    public ErrorResponse onForbiddenException(Forbidden e) {
+        return createResponseException(HttpStatus.FORBIDDEN, "Forbidden", e.getMessage());
+    }
+
     private ErrorResponse createResponseException(HttpStatus status, String error, String message) {
         return new ErrorResponse(
                 LocalDateTime.now(),
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/gradle.xml b/.idea/gradle.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/gradle.xml	
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="GradleMigrationSettings" migrationVersion="1" />
+  <component name="GradleSettings">
+    <option name="linkedExternalProjectsSettings">
+      <GradleProjectSettings>
+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
+        <option name="modules">
+          <set>
+            <option value="$PROJECT_DIR$" />
+          </set>
+        </option>
+      </GradleProjectSettings>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/misc.xml	
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ExternalStorageConfigurationManager" enabled="true" />
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_17" default="true" project-jdk-name="17" project-jdk-type="JavaSDK" />
+</project>
\ No newline at end of file
Index: src/main/java/biletka/main/Utils/FileUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.Utils;\r\n\r\nimport biletka.main.dto.universal.PublicEventImage;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport javax.imageio.ImageReader;\r\nimport javax.imageio.stream.ImageInputStream;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.*;\r\nimport java.net.URLConnection;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n@Component\r\n@Slf4j\r\npublic class FileUtils {\r\n    @Value(\"${app.file.directory}\")\r\n    private String directory;\r\n\r\n    /**\r\n     * метод получения типа файла и проверка на многотиповость\r\n     * @param fileName полновое название файла\r\n     * @return тип файла\r\n     */\r\n    public String getFileExtension(String fileName) {\r\n        Pattern pattern = Pattern.compile(\"\\\\.\");\r\n        String[] patternString = pattern.split(fileName);\r\n\r\n        if (patternString.length != 2) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"File error\", \"The file is incorrect!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        return patternString[1];\r\n    }\r\n\r\n    /**\r\n     * Метод проверки тип файла с разрешенными\r\n     * @param typeFile тип файла\r\n     * @param pattern разрешенные типы файла\r\n     */\r\n    public void validationFile(String typeFile, String[] pattern) {\r\n        if (!Arrays.asList(pattern).contains(typeFile)) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"File error\", \"The file is incorrect!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод сохранения файла в системе\r\n     * @param file файла\r\n     */\r\n    public void fileUpload(MultipartFile file, String fileName) throws IOException {\r\n        File convertFile = new File(directory+fileName);\r\n        convertFile.createNewFile();\r\n        FileOutputStream fileOut = new FileOutputStream(convertFile);\r\n        fileOut.write(file.getBytes());\r\n        fileOut.close();\r\n    }\r\n\r\n    public PublicEventImage getFileEvent(String img) throws IOException {\r\n        /** Получение файла */\r\n        File file = new File(directory + \"event/\" + img);\r\n\r\n        /** Получение содержание файла в массиве байтов */\r\n        byte[] content = Files.readAllBytes(Paths.get(directory + \"event/\" + img));\r\n\r\n        /** Получение mime типа файла */\r\n        InputStream inputStream = new BufferedInputStream(new FileInputStream(file));\r\n        String mimeType = URLConnection.guessContentTypeFromStream(inputStream);\r\n\r\n        return new PublicEventImage(\r\n                content,\r\n                img,\r\n                mimeType\r\n        );\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/Utils/FileUtils.java b/src/main/java/biletka/main/Utils/FileUtils.java
--- a/src/main/java/biletka/main/Utils/FileUtils.java	
+++ b/src/main/java/biletka/main/Utils/FileUtils.java	
@@ -25,8 +25,8 @@
 @Component
 @Slf4j
 public class FileUtils {
-    @Value("${app.file.directory}")
-    private String directory;
+    @Value("${app.file.directory.event}")
+    private String directoryEvent;
 
     /**
      * метод получения типа файла и проверка на многотиповость
@@ -64,7 +64,7 @@
      * @param file файла
      */
     public void fileUpload(MultipartFile file, String fileName) throws IOException {
-        File convertFile = new File(directory+fileName);
+        File convertFile = new File(directoryEvent+fileName);
         convertFile.createNewFile();
         FileOutputStream fileOut = new FileOutputStream(convertFile);
         fileOut.write(file.getBytes());
@@ -73,10 +73,10 @@
 
     public PublicEventImage getFileEvent(String img) throws IOException {
         /** Получение файла */
-        File file = new File(directory + "event/" + img);
+        File file = new File(directoryEvent + img);
 
         /** Получение содержание файла в массиве байтов */
-        byte[] content = Files.readAllBytes(Paths.get(directory + "event/" + img));
+        byte[] content = Files.readAllBytes(Paths.get(directoryEvent + img));
 
         /** Получение mime типа файла */
         InputStream inputStream = new BufferedInputStream(new FileInputStream(file));
Index: .idea/modules/main.main.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules/main.main.iml b/.idea/modules/main.main.iml
new file mode 100644
--- /dev/null	
+++ b/.idea/modules/main.main.iml	
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module version="4">
+  <component name="AdditionalModuleElements">
+    <content url="file://$MODULE_DIR$/../../build/generated/sources/annotationProcessor/java/main">
+      <sourceFolder url="file://$MODULE_DIR$/../../build/generated/sources/annotationProcessor/java/main" isTestSource="false" generated="true" />
+    </content>
+  </component>
+</module>
\ No newline at end of file
Index: .idea/uiDesigner.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/uiDesigner.xml b/.idea/uiDesigner.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/uiDesigner.xml	
@@ -0,0 +1,124 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.svg" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.svg" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.svg" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.svg" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
\ No newline at end of file
Index: src/main/java/biletka/main/dto/request/event_item/EventWebWidgetRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.dto.request.event_item;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport jakarta.validation.constraints.NotBlank;\r\nimport jakarta.validation.constraints.Pattern;\r\n\r\npublic record EventWebWidgetRequest(\r\n        @JsonProperty(\"description\")\r\n        @NotBlank(message = \"Description is mandatory!\")\r\n        String description,\r\n\r\n        @JsonProperty(\"link\")\r\n        @Pattern(regexp = \"https://afisha.yandex.ru/\", message = \"Invalid link format\")\r\n        @NotBlank(message = \"Link is mandatory!\")\r\n        String link,\r\n        @JsonProperty(\"signature\")\r\n        @NotBlank(message = \"Signature is mandatory!\")\r\n        String signature\r\n) {\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/request/event_item/EventWebWidgetRequest.java b/src/main/java/biletka/main/dto/request/event_item/EventWebWidgetRequest.java
--- a/src/main/java/biletka/main/dto/request/event_item/EventWebWidgetRequest.java	
+++ b/src/main/java/biletka/main/dto/request/event_item/EventWebWidgetRequest.java	
@@ -11,7 +11,6 @@
 
         @JsonProperty("link")
         @Pattern(regexp = "https://afisha.yandex.ru/", message = "Invalid link format")
-        @NotBlank(message = "Link is mandatory!")
         String link,
         @JsonProperty("signature")
         @NotBlank(message = "Signature is mandatory!")
Index: .idea/jarRepositories.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/jarRepositories.xml b/.idea/jarRepositories.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/jarRepositories.xml	
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RemoteRepositoriesConfiguration">
+    <remote-repository>
+      <option name="id" value="central" />
+      <option name="name" value="Maven Central repository" />
+      <option name="url" value="https://repo1.maven.org/maven2" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="jboss.community" />
+      <option name="name" value="JBoss Community repository" />
+      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="MavenRepo" />
+      <option name="name" value="MavenRepo" />
+      <option name="url" value="https://repo.maven.apache.org/maven2/" />
+    </remote-repository>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/vcs.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/modules.xml	
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/modules/main.main.iml" filepath="$PROJECT_DIR$/.idea/modules/main.main.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: src/main/java/biletka/main/dto/request/EventCreateRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.dto.request;\r\n\r\nimport biletka.main.dto.request.event_item.EventAdditional;\r\nimport biletka.main.dto.request.event_item.EventBasicRequest;\r\nimport biletka.main.dto.request.event_item.EventWebWidgetRequest;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport org.springframework.validation.annotation.Validated;\r\n\r\n@Validated\r\npublic record EventCreateRequest (\r\n        @JsonProperty(\"event_basic\")\r\n        EventBasicRequest eventBasicRequest,\r\n\r\n        @JsonProperty(\"event_additional\")\r\n        EventAdditional eventAdditional,\r\n\r\n        @JsonProperty(\"event_wev_widget\")\r\n        EventWebWidgetRequest webWidget,\r\n\r\n        @JsonProperty(\"duration\")\r\n        String duration\r\n) {\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/request/EventCreateRequest.java b/src/main/java/biletka/main/dto/request/EventCreateRequest.java
--- a/src/main/java/biletka/main/dto/request/EventCreateRequest.java	
+++ b/src/main/java/biletka/main/dto/request/EventCreateRequest.java	
@@ -4,20 +4,25 @@
 import biletka.main.dto.request.event_item.EventBasicRequest;
 import biletka.main.dto.request.event_item.EventWebWidgetRequest;
 import com.fasterxml.jackson.annotation.JsonProperty;
+import jakarta.validation.constraints.NotBlank;
 import org.springframework.validation.annotation.Validated;
 
 @Validated
 public record EventCreateRequest (
         @JsonProperty("event_basic")
+        @NotBlank(message = "Event basic is mandatory!")
         EventBasicRequest eventBasicRequest,
 
         @JsonProperty("event_additional")
+        @NotBlank(message = "Event additional is mandatory!")
         EventAdditional eventAdditional,
 
-        @JsonProperty("event_wev_widget")
+        @JsonProperty("event_web_widget")
+        @NotBlank(message = "Event web widget is mandatory!")
         EventWebWidgetRequest webWidget,
 
         @JsonProperty("duration")
+        @NotBlank(message = "Duration is mandatory!")
         String duration
 ) {
 }
Index: .gradle/buildOutputCleanup/cache.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/.gradle/buildOutputCleanup/cache.properties b/.gradle/buildOutputCleanup/cache.properties
new file mode 100644
--- /dev/null	
+++ b/.gradle/buildOutputCleanup/cache.properties	
@@ -0,0 +1,2 @@
+#Tue May 07 12:06:24 MSK 2024
+gradle.version=8.7
Index: src/main/java/biletka/main/service/ClientService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.dto.request.ClientRegistrationRequest;\r\nimport biletka.main.dto.response.FavoriteResponse;\r\nimport biletka.main.dto.universal.MassivePublicEvent;\r\nimport biletka.main.entity.Client;\r\nimport biletka.main.entity.Users;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.text.ParseException;\r\n\r\n@Service\r\npublic interface ClientService {\r\n    /**\r\n     * Метод добавления нового пользователя в бд\r\n     * @param clientRegistrationRequest данные пользователя\r\n     * @param user данные для входа\r\n     */\r\n    void  postNewClient(ClientRegistrationRequest clientRegistrationRequest, Users user) throws ParseException;\r\n\r\n    /**\r\n     * Метод изменения мероприятия в избранном пользователя\r\n     * @param authorization токен авторизации\r\n     * @param id мероприятия\r\n     * @return id и измененный статус избранного\r\n     */\r\n    FavoriteResponse toggleEventFavorite(String authorization, Long id);\r\n\r\n    /**\r\n     * Метод получения массива мероприятий из таблицы избранное у пользователя\r\n     * @param authorization токен авторизации\r\n     * @return массив мероприятий\r\n     */\r\n    MassivePublicEvent getFavorite(String authorization);\r\n\r\n    /**\r\n     * Метод получения клиента\r\n     * @param user почта пользователя\r\n     * @return клиент\r\n     */\r\n    Client getClientByUser(Users user);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/ClientService.java b/src/main/java/biletka/main/service/ClientService.java
--- a/src/main/java/biletka/main/service/ClientService.java	
+++ b/src/main/java/biletka/main/service/ClientService.java	
@@ -1,7 +1,9 @@
 package biletka.main.service;
 
 import biletka.main.dto.request.ClientRegistrationRequest;
+import biletka.main.dto.request.RatingClientRequest;
 import biletka.main.dto.response.FavoriteResponse;
+import biletka.main.dto.response.MessageCreateResponse;
 import biletka.main.dto.universal.MassivePublicEvent;
 import biletka.main.entity.Client;
 import biletka.main.entity.Users;
@@ -39,4 +41,12 @@
      * @return клиент
      */
     Client getClientByUser(Users user);
+
+    /**
+     * Метод изменения рейтинга мероприятия пользователем
+     * @param authorization токен авторизации
+     * @param ratingClientRequest информация для изменения рейтинга мероприятия
+     * @return успешное изменение
+     */
+    MessageCreateResponse putRatingEvent(String authorization, RatingClientRequest ratingClientRequest);
 }
Index: src/main/java/biletka/main/service/Impl/TypeEventServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.entity.TypeEvent;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.TypeEventRepository;\r\nimport biletka.main.service.TypeEventService;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class TypeEventServiceImpl implements TypeEventService {\r\n    private final TypeEventRepository typeEventRepository;\r\n\r\n    /**\r\n     * Метод получения типа мероприятия\r\n     * @param type название типа мероприяти\r\n     * @return тип мероприятия\r\n     */\r\n    @Override\r\n    public TypeEvent getTypeEventOfName(String type){\r\n        log.trace(\"TypeEventServiceImpl.getTypeEventOfName - type {}\", type);\r\n\r\n        return typeEventRepository.findFirstByType(type);\r\n    }\r\n\r\n    /**\r\n     * Метод создания типа мероприятия\r\n     * @param type навзание типа мероприятия\r\n     * @return тип мероприятия\r\n     */\r\n    @Override\r\n    public TypeEvent createTypeEvent(String type) {\r\n        log.trace(\"TypeEventServiceImpl.createTypeEvent - type {}\", type);\r\n        TypeEvent typeEvent = typeEventRepository.findFirstByType(type);\r\n\r\n        if (typeEvent != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Genre error\", \"This genre already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        TypeEvent typeEventNew = new TypeEvent(type);\r\n\r\n        typeEventRepository.saveAndFlush(typeEventNew);\r\n\r\n        return typeEventNew;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/TypeEventServiceImpl.java b/src/main/java/biletka/main/service/Impl/TypeEventServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/TypeEventServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/TypeEventServiceImpl.java	
@@ -1,5 +1,7 @@
 package biletka.main.service.Impl;
 
+import biletka.main.dto.response.MassiveTypeResponse;
+import biletka.main.dto.response.TypeResponse;
 import biletka.main.entity.TypeEvent;
 import biletka.main.exception.ErrorMessage;
 import biletka.main.exception.InvalidDataException;
@@ -52,4 +54,25 @@
 
         return typeEventNew;
     }
+
+    /**
+     * Метод вывода всех возможных типов мероприятия
+     * @return массив типов
+     */
+    @Override
+    public MassiveTypeResponse getAllType() {
+        log.trace("TypeEventServiceImpl.getAllType");
+        ArrayList<TypeResponse> typeResponseArrayList = new ArrayList<>();
+
+        typeEventRepository.findAll().forEach(typeEvent -> {
+            typeResponseArrayList.add(
+                    new TypeResponse(
+                        typeEvent.getId(),
+                        typeEvent.getType()
+                )
+            );
+        });
+
+        return new MassiveTypeResponse(typeResponseArrayList.toArray(TypeResponse[]::new));
+    }
 }
Index: src/main/java/biletka/main/service/Impl/EventBasicInformationServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.ConvertUtils;\r\nimport biletka.main.dto.request.event_item.EventBasicRequest;\r\nimport biletka.main.entity.AgeRating;\r\nimport biletka.main.entity.Genre;\r\nimport biletka.main.entity.TypeEvent;\r\nimport biletka.main.entity.event_item.EventBasicInformation;\r\n\r\nimport biletka.main.repository.EventBasicInformationRepository;\r\nimport biletka.main.service.AgeRatingService;\r\nimport biletka.main.service.EventBasicInformationService;\r\nimport biletka.main.service.GenreService;\r\nimport biletka.main.service.TypeEventService;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class EventBasicInformationServiceImpl implements EventBasicInformationService {\r\n    private final EventBasicInformationRepository eventBasicInformationRepository;\r\n    private final ConvertUtils convertUtils;\r\n\r\n    private final TypeEventService typeEventService;\r\n    private final AgeRatingService ageRatingService;\r\n    private final GenreService genreService;\r\n\r\n    /**\r\n     * Метод создания и сохранения основной информации о мероприятии в бд\r\n     * @param eventBasicRequest основная информация для создания\r\n     * @return основная информация о мероприятии\r\n     */\r\n    @Override\r\n    public EventBasicInformation createEventBasic(EventBasicRequest eventBasicRequest, String fullNameFile) {\r\n        log.trace(\"EventBasicInformationServiceImpl.createEventBasic - eventBasicRequest {}, fullNameFile {}\", eventBasicRequest, fullNameFile);\r\n        /** Проверка на существование типа мероприятия */\r\n        TypeEvent type = typeEventService.getTypeEventOfName(eventBasicRequest.typeEvent());\r\n\r\n        if (type == null) {\r\n            type = typeEventService.createTypeEvent(eventBasicRequest.typeEvent());\r\n        }\r\n\r\n        /** Получение возрастного ограничения */\r\n        AgeRating ageRating = ageRatingService.getAgeRatingOfLimitation(eventBasicRequest.ageRating());\r\n\r\n        /** Проверка на существование жанров */\r\n        Set<Genre> genreSet = new HashSet<>();\r\n\r\n        for (String genreRequest: eventBasicRequest.genres()) {\r\n            Genre genre = genreService.getGenreOfName(genreRequest);\r\n\r\n            if (genre == null) {\r\n                genre = genreService.createGenre(genreRequest);\r\n            }\r\n\r\n            genreSet.add(genre);\r\n        }\r\n\r\n        /** Сохранение в бд */\r\n        EventBasicInformation eventBasicInformation = new EventBasicInformation(\r\n                eventBasicRequest.name(),\r\n                convertUtils.convertToSymbolicString(eventBasicRequest.name()),\r\n                eventBasicRequest.nameRus(),\r\n                eventBasicRequest.organizaer(),\r\n                ageRating,\r\n                type,\r\n                eventBasicRequest.pushkin(),\r\n                eventBasicRequest.eventIdCulture(),\r\n                eventBasicRequest.showInPoster(),\r\n                fullNameFile,\r\n                genreSet\r\n        );\r\n\r\n        eventBasicInformationRepository.saveAndFlush(eventBasicInformation);\r\n\r\n        return eventBasicInformation;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/EventBasicInformationServiceImpl.java b/src/main/java/biletka/main/service/Impl/EventBasicInformationServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/EventBasicInformationServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/EventBasicInformationServiceImpl.java	
@@ -40,10 +40,10 @@
     public EventBasicInformation createEventBasic(EventBasicRequest eventBasicRequest, String fullNameFile) {
         log.trace("EventBasicInformationServiceImpl.createEventBasic - eventBasicRequest {}, fullNameFile {}", eventBasicRequest, fullNameFile);
         /** Проверка на существование типа мероприятия */
-        TypeEvent type = typeEventService.getTypeEventOfName(eventBasicRequest.typeEvent());
+        TypeEvent type = typeEventService.getTypeEventOfName(eventBasicRequest.typeEvent().substring(0, 1).toUpperCase() + eventBasicRequest.typeEvent().substring(1).toLowerCase());
 
         if (type == null) {
-            type = typeEventService.createTypeEvent(eventBasicRequest.typeEvent());
+            type = typeEventService.createTypeEvent(eventBasicRequest.typeEvent().substring(0, 1).toUpperCase() + eventBasicRequest.typeEvent().substring(1).toLowerCase());
         }
 
         /** Получение возрастного ограничения */
@@ -53,7 +53,7 @@
         Set<Genre> genreSet = new HashSet<>();
 
         for (String genreRequest: eventBasicRequest.genres()) {
-            Genre genre = genreService.getGenreOfName(genreRequest);
+            Genre genre = genreService.getGenreOfName(genreRequest.substring(0, 1).toUpperCase() + genreRequest.substring(1).toLowerCase());
 
             if (genre == null) {
                 genre = genreService.createGenre(genreRequest);
Index: src/main/java/biletka/main/service/EventService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.dto.request.EventCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.universal.MassivePublicEvent;\r\nimport biletka.main.dto.universal.PublicEventImage;\r\nimport biletka.main.dto.universal.PublicFullInfoEvent;\r\nimport biletka.main.entity.Event;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.IOException;\r\nimport java.util.Date;\r\n\r\n@Service\r\npublic interface EventService {\r\n    /**\r\n     * Метод создания и добавления мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param file изображение мероприятия\r\n     * @param eventCreateRequest информация мероприятия\r\n     * @return сообщение оуспешном создании мероприятия\r\n     */\r\n    MessageCreateResponse createEvent(String authorization, MultipartFile file, EventCreateRequest eventCreateRequest) throws IOException;\r\n\r\n    /**\r\n     * Метод получения мероприятия по id\r\n     * @param id мероприятия\r\n     * @return мероприятие\r\n     */\r\n    Event getEventById(Long id);\r\n\r\n    /**\r\n     * Метод получения изображения мероприятия\r\n     * @param id мероприятия\r\n     * @param symbolicName символичное название мероприятия\r\n     * @return данные для изображения\r\n     */\r\n    PublicEventImage getImageEvent(String id, String symbolicName) throws IOException;\r\n\r\n    /**\r\n     * Метод получения кртакой информации о 10 мероприятиях по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getEventLimit(String cityName, String authorization, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения анонсов 10 мероприятий по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getAnnouncementLimit(String cityName, String authorization, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения полной информации меропрития и места проведения и его сеансов\r\n     * @param authorization токе авторизации\r\n     * @param cityName название города\r\n     * @param eventName id и символьное название мероприятия\r\n     * @param date дата для поиска\r\n     * @return полная информация мероприятия\r\n     */\r\n    PublicFullInfoEvent getFullInfoEvent(String authorization, String cityName, String eventName, Date date);\r\n\r\n    /**\r\n     * Метод получения кртакой информации о мероприятиях подходящих под указанный возраст\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getEventsByCityAndAgeLimit(String cityName, int age, String authorization, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения кртакой информации о мероприятиях подходящих под указанный тип\r\n     * @param cityName название города\r\n     * @param type тип мероприятия\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getEventsByCityAndType(String cityName, String type, String authorization, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения мероприятия по городу и жанру\r\n     * @param cityName название города\r\n     * @param Genre тип мероприятия\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/EventService.java b/src/main/java/biletka/main/service/EventService.java
--- a/src/main/java/biletka/main/service/EventService.java	
+++ b/src/main/java/biletka/main/service/EventService.java	
@@ -68,6 +68,7 @@
     PublicFullInfoEvent getFullInfoEvent(String authorization, String cityName, String eventName, Date date);
 
     /**
+<<<<<<< HEAD
      * Метод получения кртакой информации о мероприятиях подходящих под указанный возраст
      * @param cityName название города
      * @param authorization токен авторизации
@@ -98,4 +99,18 @@
      * @return массив краткой информации
      */
     MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date);
+=======
+     * Метод получения мероприятия по id и символьному названию
+     * @param eventSymbolic id и символьное название
+     * @return мероприятие
+     */
+    Event getEventByIdAndSymbolic(String eventSymbolic);
+
+    /**
+     * Метод изменения рейтинга мероприятия
+     * @param event мероприятие
+     * @param rating рейтинг пользователя
+     */
+    void putRatingEvent(Event event, Double rating);
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 }
Index: src/main/java/biletka/main/service/OrganizationService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.dto.request.OrganizationRegistrationRequest;\r\n\r\nimport biletka.main.dto.response.OrganizationResponse;\r\nimport biletka.main.dto.response.TotalSession.TotalSession;\r\nimport biletka.main.entity.Event;\r\nimport biletka.main.entity.Organization;\r\nimport biletka.main.entity.Place;\r\nimport biletka.main.entity.Users;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic interface OrganizationService {\r\n    /**\r\n     * Метод добавления организации в бд\r\n     * @param organizationRegistrationRequest данные организации\r\n     * @param user данные о новом пользователе\r\n     */\r\n    void postCreateOrganization(OrganizationRegistrationRequest organizationRegistrationRequest, Users user);\r\n\r\n    /**\r\n     * Метод получения организации по данным\r\n     * @param organizationRegistrationRequest данные организации\r\n     * @return организация\r\n     */\r\n    Organization getOrganizationByFullNameOrganization(OrganizationRegistrationRequest organizationRegistrationRequest);\r\n\r\n    /**\r\n     * Метод получения организации по пользователю\r\n     * @param user пользователь\r\n     * @return организация\r\n     */\r\n    Organization getOrganizationByUser(Users user);\r\n\r\n    /**\r\n     * Метод добавление площадки к организации\r\n     * @param newPlace площадка\r\n     */\r\n    void addPlace(Organization organization, Place newPlace);\r\n\r\n    /**\r\n     * Метод добавление мероприятия к организации\r\n     * @param event мероприятие\r\n     */\r\n    void addEventAdmin(Organization organization, Event event);\r\n\r\n    /**\r\n     * Метод получения организации по токену\r\n     * @param authorization - токен авторизации\r\n     * @return организация\r\n     */\r\n    OrganizationResponse getOrganization(String authorization);\r\n\r\n    /**\r\n     * Метод получения сеансов по токену\r\n     * @param authorization - токен авторизации\r\n     * @return массив сеансов по площадкам и мероприятиям\r\n     */\r\n    TotalSession getSessionsByOrganization(String authorization);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/OrganizationService.java b/src/main/java/biletka/main/service/OrganizationService.java
--- a/src/main/java/biletka/main/service/OrganizationService.java	
+++ b/src/main/java/biletka/main/service/OrganizationService.java	
@@ -1,9 +1,15 @@
 package biletka.main.service;
 
 import biletka.main.dto.request.OrganizationRegistrationRequest;
+<<<<<<< HEAD
 
 import biletka.main.dto.response.OrganizationResponse;
 import biletka.main.dto.response.TotalSession.TotalSession;
+=======
+import biletka.main.dto.response.EventsOrganization;
+import biletka.main.dto.response.MassivePlacesAndHalls;
+import biletka.main.dto.response.PlacesOrganization;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 import biletka.main.entity.Event;
 import biletka.main.entity.Organization;
 import biletka.main.entity.Place;
@@ -46,6 +52,7 @@
     void addEventAdmin(Organization organization, Event event);
 
     /**
+<<<<<<< HEAD
      * Метод получения организации по токену
      * @param authorization - токен авторизации
      * @return организация
@@ -58,4 +65,25 @@
      * @return массив сеансов по площадкам и мероприятиям
      */
     TotalSession getSessionsByOrganization(String authorization);
+=======
+     * Метод получения мероприятий организации
+     * @param authorization токен пользователя
+     * @return массив мероприятий и их количесто
+     */
+    EventsOrganization getEventsOrganization(String authorization);
+
+    /**
+     * Метод получения площадок организации
+     * @param authorization токен пользователя
+     * @return массив площадок
+     */
+    PlacesOrganization getPlacesOrganization(String authorization);
+
+    /**
+     * Метод получения залов у организации
+     * @param authorization токе авторизации
+     * @return массив залов
+     */
+    MassivePlacesAndHalls getPlacesAndSession(String authorization);
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 }
Index: src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.OrganizationRegistrationRequest;\r\nimport biletka.main.dto.response.OrganizationResponse;\r\nimport biletka.main.dto.response.TotalSession.PlacesByOrganization;\r\nimport biletka.main.dto.response.TotalSession.TotalSession;\r\nimport biletka.main.dto.response.TotalSession.EventsByPlace;\r\nimport biletka.main.entity.Event;\r\nimport biletka.main.entity.Organization;\r\nimport biletka.main.entity.Place;\r\nimport biletka.main.entity.Users;\r\nimport biletka.main.enums.StatusUserEnum;\r\nimport biletka.main.repository.OrganizationRepository;\r\nimport biletka.main.service.OrganizationService;\r\nimport biletka.main.service.SessionService;\r\nimport biletka.main.service.UserService;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\n// не ту библиотеку инициализировал. Нужна была не ломбока\r\n\r\nimport java.sql.Timestamp;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.Set;\r\n\r\n@Service\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\n@Slf4j\r\npublic class OrganizationServiceImpl implements OrganizationService {\r\n    private final OrganizationRepository organizationRepository;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final SessionService sessionService;\r\n\r\n    @Lazy\r\n    private final UserService userService;\r\n\r\n\r\n    /**\r\n     * Метод добавления организации в бд\r\n     * @param organizationRequest данные организации\r\n     * @param user данные о новом пользователе\r\n     */\r\n    @Override\r\n    public void postCreateOrganization(OrganizationRegistrationRequest organizationRequest, Users user) {\r\n        log.trace(\"OrganizationServiceImpl.postCreateOrganization - organizationRequest {}, user {}\", organizationRequest, user);\r\n        Organization organization = new Organization(\r\n                user,\r\n                organizationRequest.inn(),\r\n                organizationRequest.kbk(),\r\n                organizationRequest.kpp(),\r\n                organizationRequest.ogrn(),\r\n                organizationRequest.oktmo(),\r\n                organizationRequest.contactPhone(),\r\n                organizationRequest.email(),\r\n                organizationRequest.fullNameOrganization(),\r\n                organizationRequest.fullNameSignatory(),\r\n                organizationRequest.legalAddress(),\r\n                organizationRequest.namePayer(),\r\n                organizationRequest.positionSignatory(),\r\n                Integer.valueOf(organizationRequest.postalAddress()),\r\n                new Timestamp(new Date().getTime()),\r\n                StatusUserEnum.ACTIVE,\r\n                null\r\n        );\r\n\r\n        organizationRepository.saveAndFlush(organization);\r\n    }\r\n\r\n    /**\r\n     * Метод получения организации по данным\r\n     * @param organizationRequest данные организации\r\n     * @return организация\r\n     */\r\n    @Override\r\n    public Organization getOrganizationByFullNameOrganization(OrganizationRegistrationRequest organizationRequest) {\r\n        log.trace(\"OrganizationServiceImpl.getOrganizationByFullNameOrganization - organizationRequest {}\", organizationRequest);\r\n        return organizationRepository.findFirstByFullInfo(\r\n                organizationRequest.inn(),\r\n                organizationRequest.kbk(),\r\n                organizationRequest.kpp(),\r\n                organizationRequest.ogrn(),\r\n                organizationRequest.oktmo(),\r\n                organizationRequest.email(),\r\n                organizationRequest.fullNameOrganization()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения организации по пользователю\r\n     * @param user пользователь\r\n     * @return организация\r\n     */\r\n    @Override\r\n    public Organization getOrganizationByUser(Users user) {\r\n        log.trace(\"OrganizationServiceImpl.getOrganizationByUser - user {}\", user);\r\n        return organizationRepository.findFirstByUser(user);\r\n    }\r\n\r\n    /**\r\n     * Метод добавление площадки к организации\r\n     * @param newPlace площадка\r\n     */\r\n    @Override\r\n    public void addPlace(Organization organization, Place newPlace) {\r\n        log.trace(\"OrganizationServiceImpl.addPlace - organization {}, newPlace {}\", organization, newPlace);\r\n        organization.addPlace(newPlace);\r\n\r\n        organizationRepository.save(organization);\r\n    }\r\n\r\n    /**\r\n     * Метод добавление мероприятия к организации\r\n     * @param event мероприятие\r\n     */\r\n    @Override\r\n    public void addEventAdmin(Organization organization, Event event) {\r\n        log.trace(\"OrganizationServiceImpl.addEventAdmin - organization {}, event {}\", organization, event);\r\n        Set<Event> eventSet = organization.getAdminEventSet();\r\n        eventSet.add(event);\r\n\r\n        organization.addEvent(event);\r\n        organization.setAdminEventSet(eventSet);\r\n\r\n        organizationRepository.save(organization);\r\n    }\r\n\r\n    /**\r\n     * Метод получения организации по токену\r\n     * @param authorization - токен авторизации\r\n     * @return организация\r\n     */\r\n    @Override\r\n    public OrganizationResponse getOrganization(String authorization){\r\n        log.trace(\"OrganizationServiceImpl.getAllOrganization - authorization {}\", authorization);\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n        return new OrganizationResponse(\r\n                organization.getId(),\r\n                organization.getUser(),\r\n                organization.getInn(),\r\n                organization.getKbk(),\r\n                organization.getKpp(),\r\n                organization.getOgrn(),\r\n                organization.getOktmo(),\r\n                organization.getContactPhone(),\r\n                organization.getEmail(),\r\n                organization.getFullNameOrganization(),\r\n                organization.getFullNameSignatory(),\r\n                organization.getLegalAddress(),\r\n                organization.getNamePayer(),\r\n                organization.getPositionSignatory(),\r\n                organization.getPostalAddress()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения сеансов по токену\r\n     * @param authorization - токен авторизации\r\n     * @return массив сеансов по площадкам и мероприятиям\r\n     */\r\n    @Override\r\n    public TotalSession getSessionsByOrganization(String authorization){\r\n        log.trace(\"OrganizationServiceImpl.getSessionsByOrganization - authorization {}\", authorization);\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        ArrayList<PlacesByOrganization> places = new ArrayList<>();\r\n\r\n        Set<Place> placeSet = organization.getPlaceSet();\r\n\r\n        placeSet.forEach(place -> {\r\n            places.add(\r\n                    new PlacesByOrganization(\r\n                            place.getPlaceName(),\r\n                            place.getCity().getCityName(),\r\n                            place.getAddress(),\r\n                            sessionService.getSessionByPlaceAndEvent(place)\r\n                    )\r\n            );\r\n        });\r\n        return new TotalSession(places.toArray(PlacesByOrganization[]::new));\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java b/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java	
@@ -2,6 +2,7 @@
 
 import biletka.main.Utils.JwtTokenUtils;
 import biletka.main.dto.request.OrganizationRegistrationRequest;
+<<<<<<< HEAD
 import biletka.main.dto.response.OrganizationResponse;
 import biletka.main.dto.response.TotalSession.PlacesByOrganization;
 import biletka.main.dto.response.TotalSession.TotalSession;
@@ -10,8 +11,13 @@
 import biletka.main.entity.Organization;
 import biletka.main.entity.Place;
 import biletka.main.entity.Users;
+=======
+import biletka.main.dto.response.*;
+import biletka.main.entity.*;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 import biletka.main.enums.StatusUserEnum;
 import biletka.main.repository.OrganizationRepository;
+import biletka.main.service.HallService;
 import biletka.main.service.OrganizationService;
 import biletka.main.service.SessionService;
 import biletka.main.service.UserService;
@@ -33,11 +39,19 @@
 public class OrganizationServiceImpl implements OrganizationService {
     private final OrganizationRepository organizationRepository;
     private final JwtTokenUtils jwtTokenUtils;
+<<<<<<< HEAD
     private final SessionService sessionService;
 
     @Lazy
     private final UserService userService;
 
+=======
+
+    @Lazy
+    private final UserService userService;
+    private final SessionService sessionService;
+    private final HallService hallService;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 
     /**
      * Метод добавления организации в бд
@@ -129,6 +143,7 @@
     }
 
     /**
+<<<<<<< HEAD
      * Метод получения организации по токену
      * @param authorization - токен авторизации
      * @return организация
@@ -167,10 +182,45 @@
                 organization.getNamePayer(),
                 organization.getPositionSignatory(),
                 organization.getPostalAddress()
+=======
+     * Метод получения мероприятий организации
+     * @param authorization токен авторизации
+     * @return массив мероприятий и их количесто
+     */
+    @Override
+    public EventsOrganization getEventsOrganization(String authorization) {
+        log.trace("OrganizationServiceImpl.getEventsOrganization - authorization {}", authorization);
+
+        Organization organization = tokenVerification(authorization);
+
+        ArrayList<EventOrganization> eventsOrganization = new ArrayList<>();
+
+        organization.getEventSet().forEach(event -> {
+            eventsOrganization.add(
+                    new EventOrganization(
+                        event.getId(),
+                        event.getEventBasicInformation().getName_rus(),
+                        event.getEventBasicInformation().getSymbolicName(),
+                        event.getRating(),
+                        event.getDuration(),
+                        event.getEventBasicInformation().getPushkin(),
+                        event.getEventAdditionalInformation().getTagSet().toArray(Tag[]::new),
+                        event.getEventBasicInformation().getGenres().toArray(Genre[]::new),
+                        String.valueOf(event.getEventBasicInformation().getAgeRatingId().getLimitation()),
+                        sessionService.getTotalByEventAndPlaces(event, organization.getPlaceSet())
+                )
+            );
+        });
+
+        return new EventsOrganization(
+                eventsOrganization.size(),
+                eventsOrganization.toArray(EventOrganization[]::new)
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
         );
     }
 
     /**
+<<<<<<< HEAD
      * Метод получения сеансов по токену
      * @param authorization - токен авторизации
      * @return массив сеансов по площадкам и мероприятиям
@@ -211,4 +261,103 @@
         return new TotalSession(places.toArray(PlacesByOrganization[]::new));
     }
 
+=======
+     * Метод получения площадок организации
+     * @param authorization токен пользователя
+     * @return массив площадок
+     */
+    @Override
+    public PlacesOrganization getPlacesOrganization(String authorization) {
+        log.trace("OrganizationServiceImpl.getPlacesOrganization - authorization {}", authorization);
+
+        Organization organization = tokenVerification(authorization);
+
+        ArrayList<PlaceOrganization> placeOrganizationArrayList = new ArrayList<>();
+
+        organization.getPlaceSet().forEach(place -> {
+            placeOrganizationArrayList.add(
+                    new PlaceOrganization(
+                            place.getId(),
+                            place.getAddress(),
+                            place.getCity().getCityName(),
+                            place.getPlaceName(),
+                            hallService.getTotalByPlace(place)
+                    )
+            );
+        });
+
+        return new PlacesOrganization(
+                placeOrganizationArrayList.size(),
+                placeOrganizationArrayList.toArray(PlaceOrganization[]::new)
+        );
+    }
+
+    /**
+     * Метод получения залов у организации
+     * @param authorization токе авторизации
+     * @return массив залов
+     */
+    @Override
+    public MassivePlacesAndHalls getPlacesAndSession(String authorization) {
+        log.trace("OrganizationServiceImpl.getPlacesAndSession - authorization {}", authorization);
+        Organization organization = tokenVerification(authorization);
+
+        ArrayList<PlaceHallOrganization> placeHallOrganizationArrayList = new ArrayList<>();
+
+        organization.getPlaceSet().forEach(place -> {
+            ArrayList<HallOrganization> hallOrganizationArrayList = new ArrayList<>();
+
+            hallService.getAllHallByPlace(place).forEach(hall -> {
+                hallOrganizationArrayList.add(
+                        new HallOrganization(
+                                hall.getId(),
+                                hall.getHallNumber(),
+                                hall.getHallName(),
+                                hall.getNumberOfSeats(),
+                                hall.getInfo(),
+                                hall.getScheme() == null
+                        )
+                );
+            });
+
+            placeHallOrganizationArrayList.add(
+                    new PlaceHallOrganization(
+                            place.getId(),
+                            place.getPlaceName(),
+                            place.getAddress(),
+                            place.getCity().getCityName(),
+                            hallOrganizationArrayList.toArray(HallOrganization[]::new)
+                    )
+            );
+        });
+
+        return new MassivePlacesAndHalls(placeHallOrganizationArrayList.toArray(PlaceHallOrganization[]::new));
+    }
+
+    /**
+     * Проверка токена авторизации и вывод организации
+     * @param token токен авторизации
+     * @return организация
+     */
+    public Organization tokenVerification(String token) {
+        log.trace("OrganizationServiceImpl.tokenVerification - token {}", token);
+        String userEmail = jwtTokenUtils.getUsernameFromToken(
+                token.substring(7)
+        );
+
+        Users user = userService.getUserOrganizationByEmail(userEmail);
+
+        if (user == null) {
+            throw new EntityNotFoundException("A broken token!");
+        }
+
+        Organization organization = getOrganizationByUser(user);
+
+        if (organization == null) {
+            throw new EntityNotFoundException("A broken token!");
+        }
+
+        return organization;
+    }
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
 }
Index: build/resources/main/templates/activationCode.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build/resources/main/templates/activationCode.html b/build/resources/main/templates/activationCode.html
new file mode 100644
--- /dev/null	
+++ b/build/resources/main/templates/activationCode.html	
@@ -0,0 +1,140 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" xmlns:o="urn:schemas-microsoft-com:office:office" lang="en" style="padding:0;Margin:0">
+ <head>
+  <meta charset="UTF-8">
+  <meta content="width=device-width, initial-scale=1" name="viewport">
+  <meta name="x-apple-disable-message-reformatting">
+  <meta http-equiv="X-UA-Compatible" content="IE=edge">
+  <meta content="telephone=no" name="format-detection">
+  <title>Новое письмо 2</title><!--[if (mso 16)]>
+    <style type="text/css">
+    a {text-decoration: none;}
+    </style>
+    <![endif]--><!--[if gte mso 9]><style>sup { font-size: 100% !important; }</style><![endif]--><!--[if gte mso 9]>
+<xml>
+    <o:OfficeDocumentSettings>
+    <o:AllowPNG></o:AllowPNG>
+    <o:PixelsPerInch>96</o:PixelsPerInch>
+    </o:OfficeDocumentSettings>
+</xml>
+<![endif]--><!--[if !mso]>-->
+  <link href="https://stripo.email/" rel="stylesheet"><!--<![endif]-->
+  <style type="text/css">
+.rollover span {
+	font-size:0;
+}
+.section-title {
+	padding:10px 15px;
+	background-color:#f6f6f6;
+	border:1px solid #dfdfdf;
+	outline:0;
+	border-radius:8px;
+	margin-bottom:15px;
+}
+#outlook a {
+	padding:0;
+}
+.ExternalClass {
+	width:100%;
+}
+.ExternalClass,
+.ExternalClass p,
+.ExternalClass span,
+.ExternalClass font,
+.ExternalClass td,
+.ExternalClass div {
+	line-height:100%;
+}
+.es-button {
+	mso-style-priority:100!important;
+	text-decoration:none!important;
+}
+a[x-apple-data-detectors] {
+	color:inherit!important;
+	text-decoration:none!important;
+	font-size:inherit!important;
+	font-family:inherit!important;
+	font-weight:inherit!important;
+	line-height:inherit!important;
+}
+.es-desk-hidden {
+	display:none;
+	float:left;
+	overflow:hidden;
+	width:0;
+	max-height:0;
+	line-height:0;
+	mso-hide:all;
+}
+@media only screen and (max-width:600px) {p, ul li, ol li, a { line-height:150%!important } h1, h2, h3, h1 a, h2 a, h3 a { line-height:120% } h1 { font-size:26px!important; text-align:left } h2 { font-size:22px!important; text-align:left } h3 { font-size:18px!important; text-align:left } h1 a { text-align:left } .es-header-body h1 a, .es-content-body h1 a, .es-footer-body h1 a { font-size:26px!important } h2 a { text-align:left } .es-header-body h2 a, .es-content-body h2 a, .es-footer-body h2 a { font-size:22px!important } h3 a { text-align:left } .es-header-body h3 a, .es-content-body h3 a, .es-footer-body h3 a { font-size:18px!important } .es-menu td a { font-size:12px!important } .es-header-body p, .es-header-body ul li, .es-header-body ol li, .es-header-body a { font-size:12px!important } .es-content-body p, .es-content-body ul li, .es-content-body ol li, .es-content-body a { font-size:14px!important } .es-footer-body p, .es-footer-body ul li, .es-footer-body ol li, .es-footer-body a { font-size:12px!important } .es-infoblock p, .es-infoblock ul li, .es-infoblock ol li, .es-infoblock a { font-size:12px!important } *[class="gmail-fix"] { display:none!important } .es-m-txt-c, .es-m-txt-c h1, .es-m-txt-c h2, .es-m-txt-c h3 { text-align:center!important } .es-m-txt-r, .es-m-txt-r h1, .es-m-txt-r h2, .es-m-txt-r h3 { text-align:right!important } .es-m-txt-l, .es-m-txt-l h1, .es-m-txt-l h2, .es-m-txt-l h3 { text-align:left!important } .es-m-txt-r img, .es-m-txt-c img, .es-m-txt-l img { display:inline!important } .es-button-border { display:inline-block!important } a.es-button, button.es-button { font-size:12px!important; display:inline-block!important } .es-btn-fw { border-width:10px 0px!important; text-align:center!important } .es-adaptive table, .es-btn-fw, .es-btn-fw-brdr, .es-left, .es-right { width:100%!important } .es-content table, .es-header table, .es-footer table, .es-content, .es-footer, .es-header { width:100%!important; max-width:600px!important } .es-adapt-td { display:block!important; width:100%!important } .adapt-img { width:100%!important; height:auto!important } .es-m-p0 { padding:0!important } .es-m-p0r { padding-right:0!important } .es-m-p0l { padding-left:0!important } .es-m-p0t { padding-top:0!important } .es-m-p0b { padding-bottom:0!important } .es-m-p20b { padding-bottom:20px!important } .es-mobile-hidden, .es-hidden { display:none!important } tr.es-desk-hidden, td.es-desk-hidden, table.es-desk-hidden { width:auto!important; overflow:visible!important; float:none!important; max-height:inherit!important; line-height:inherit!important } tr.es-desk-hidden { display:table-row!important } table.es-desk-hidden { display:table!important } td.es-desk-menu-hidden { display:table-cell!important } table.es-table-not-adapt, .esd-block-html table { width:auto!important } table.es-social { display:inline-block!important } table.es-social td { display:inline-block!important } .es-m-p5 { padding:5px!important } .es-m-p5t { padding-top:5px!important } .es-m-p5b { padding-bottom:5px!important } .es-m-p5r { padding-right:5px!important } .es-m-p5l { padding-left:5px!important } .es-m-p10 { padding:10px!important } .es-m-p10t { padding-top:10px!important } .es-m-p10b { padding-bottom:10px!important } .es-m-p10r { padding-right:10px!important } .es-m-p10l { padding-left:10px!important } .es-m-p15 { padding:15px!important } .es-m-p15t { padding-top:15px!important } .es-m-p15b { padding-bottom:15px!important } .es-m-p15r { padding-right:15px!important } .es-m-p15l { padding-left:15px!important } .es-m-p20 { padding:20px!important } .es-m-p20t { padding-top:20px!important } .es-m-p20r { padding-right:20px!important } .es-m-p20l { padding-left:20px!important } .es-m-p25 { padding:25px!important } .es-m-p25t { padding-top:25px!important } .es-m-p25b { padding-bottom:25px!important } .es-m-p25r { padding-right:25px!important } .es-m-p25l { padding-left:25px!important } .es-m-p30 { padding:30px!important } .es-m-p30t { padding-top:30px!important } .es-m-p30b { padding-bottom:30px!important } .es-m-p30r { padding-right:30px!important } .es-m-p30l { padding-left:30px!important } .es-m-p35 { padding:35px!important } .es-m-p35t { padding-top:35px!important } .es-m-p35b { padding-bottom:35px!important } .es-m-p35r { padding-right:35px!important } .es-m-p35l { padding-left:35px!important } .es-m-p40 { padding:40px!important } .es-m-p40t { padding-top:40px!important } .es-m-p40b { padding-bottom:40px!important } .es-m-p40r { padding-right:40px!important } .es-m-p40l { padding-left:40px!important } .es-desk-hidden { display:table-row!important; width:auto!important; overflow:visible!important; max-height:inherit!important } }
+@media screen and (max-width:384px) {.mail-message-content { width:414px!important } }
+</style>
+ </head>
+ <body style="width:100%;font-family:arial, 'helvetica neue', helvetica, sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;padding:0;Margin:0">
+  <div dir="ltr" class="es-wrapper-color" lang="en" style="background-color:#F0F0F0"><!--[if gte mso 9]>
+			<v:background xmlns:v="urn:schemas-microsoft-com:vml" fill="t">
+				<v:fill type="tile" color="#f0f0f0"></v:fill>
+			</v:background>
+		<![endif]-->
+   <table class="es-wrapper" width="100%" cellspacing="0" cellpadding="0" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;padding:0;Margin:0;width:100%;height:100%;background-repeat:repeat;background-position:center top;background: linear-gradient(45deg, rgba(0,0,248,0.70), rgba(255,0,4,0.70));">
+     <tr style="border-collapse:collapse">
+      <td valign="top" style="padding:0;Margin:0">
+       <table cellpadding="0" cellspacing="0" class="es-content" align="center" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%">
+         <tr style="border-collapse:collapse">
+          <td align="center" style="padding:0;Margin:0">
+           <table bgcolor="#ffffff" class="es-content-body" align="center" cellpadding="0" cellspacing="0" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:#FFFFFF;width:600px">
+             <tr style="border-collapse:collapse">
+              <td align="left" style="padding:30px;Margin:0">
+               <table cellpadding="0" cellspacing="0" width="100%" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
+                 <tr style="border-collapse:collapse">
+                  <td align="center" valign="top" style="padding:0;Margin:0;width:540px">
+                   <table cellpadding="0" cellspacing="0" width="100%" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
+                     <tr style="border-collapse:collapse">
+                      <td align="center" class="es-m-p30r es-m-p30l" style="padding:0;Margin:0;font-size:0px"><img class="adapt-img" src="https://fbffqwq.stripocdn.email/content/guids/CABINET_4fdd20088a4579cd1e96e72ed216b9da/images/beaming_face_with_smiling_eyes.gif" alt style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic" width="128"></td>
+                     </tr>
+                     <tr style="border-collapse:collapse">
+                      <td align="center" class="es-m-txt-c" style="padding:0;Margin:0;padding-top:20px"><h1 style="Margin:0;line-height:34px;mso-line-height-rule:exactly;font-family:'Arial Narrow', Arial, sans-serif;letter-spacing:0.5px;font-size:28px;font-style:normal;font-weight:normal;color:#333333">Код подтверждения</h1></td>
+                     </tr>
+                     <tr style="border-collapse:collapse">
+                         <td align="center" class="es-m-txt-c" style="padding:0;Margin:0;padding-top:10px;padding-bottom:20px"><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:21px;color:#999999;font-size:14px">Введите код на <a href="https://ticket-zone.ru/">сайте Ticket-zone.com</a>, для подтверждения своей почты<strong></strong></p></td>
+                     </tr>
+                   </table></td>
+                 </tr>
+                 <tr style="border-collapse:collapse">
+                  <td align="center" valign="top" style="padding:0;Margin:0;width:540px">
+                   <table cellpadding="0" cellspacing="0" width="100%" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:separate;border-spacing:0px;border-left:2px dashed #0081ff;border-right:2px dashed #0081ff;border-top:2px dashed #0081ff;border-bottom:2px dashed #0081ff;border-radius:12px" role="presentation">
+                     <tr style="border-collapse:collapse">
+                      <td align="center" class="es-m-txt-c" style="padding:0;Margin:0;padding-top:20px;padding-bottom:20px"><h2 style="Margin:0;line-height:29px;mso-line-height-rule:exactly;font-family:-apple-system, blinkmacsystemfont, 'segoe ui', roboto, helvetica, arial, sans-serif, 'apple color emoji', 'segoe ui emoji', 'segoe ui symbol';letter-spacing:0.5px;font-size:24px;font-style:normal;font-weight:normal;color:#333333" th:text="${code}"></h2></td>
+                     </tr>
+                   </table></td>
+                 </tr>
+               </table></td>
+             </tr>
+           </table></td>
+         </tr>
+       </table>
+       <table cellpadding="0" cellspacing="0" class="es-footer" align="center" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%;background-color:transparent;background-repeat:repeat;background-position:center top">
+         <tr style="border-collapse:collapse">
+          <td align="center" style="padding:0;Margin:0">
+           <table bgcolor="#ffffff" class="es-footer-body" align="center" cellpadding="0" cellspacing="0" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:#FFFFFF;width:600px">
+             <tr style="border-collapse:collapse">
+              <td align="left" style="padding:0;Margin:0;padding-top:30px;padding-left:30px;padding-right:30px">
+               <table cellpadding="0" cellspacing="0" width="100%" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
+                 <tr style="border-collapse:collapse">
+                  <td align="center" valign="top" style="padding:0;Margin:0;width:540px">
+                   <table cellpadding="0" cellspacing="0" width="100%" bgcolor="#efefef" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:separate;border-spacing:0px;background-color:#efefef;border-radius:16px" role="none">
+                     <tr style="border-collapse:collapse">
+                      <td align="center" style="padding:0;Margin:0;display:none"></td>
+                     </tr>
+                   </table></td>
+                 </tr>
+               </table></td>
+             </tr>
+           </table></td>
+         </tr>
+       </table>
+     </tr>
+   </table>
+  </div>
+ </body>
+</html>
\ No newline at end of file
Index: src/main/java/biletka/main/service/Impl/ClientServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.ClientRegistrationRequest;\r\nimport biletka.main.dto.response.FavoriteResponse;\r\nimport biletka.main.dto.universal.MassivePublicEvent;\r\nimport biletka.main.dto.universal.PublicEvent;\r\nimport biletka.main.entity.Client;\r\nimport biletka.main.entity.Event;\r\nimport biletka.main.entity.Genre;\r\nimport biletka.main.entity.Users;\r\nimport biletka.main.enums.StatusUserEnum;\r\nimport biletka.main.repository.ClientRepository;\r\nimport biletka.main.service.ClientService;\r\nimport biletka.main.service.EventService;\r\nimport biletka.main.service.UserService;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.sql.Timestamp;\r\nimport java.text.ParseException;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n@Service\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\n@Slf4j\r\npublic class ClientServiceImpl implements ClientService {\r\n    private final ClientRepository clientRepository;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n\r\n    @Lazy\r\n    private final UserService userService;\r\n    private final EventService eventService;\r\n\r\n    /**\r\n     * Метод добавления нового пользователя в бд\r\n     * @param client данные пользователя\r\n     * @param user данные для входа\r\n     */\r\n    @Override\r\n    public void postNewClient(ClientRegistrationRequest client, Users user) throws ParseException {\r\n        log.trace(\"ClientServiceImpl.postNewClient - client {}, user {}\", client, user);\r\n        Client newClient = new Client(\r\n            user,\r\n            client.fullName(),\r\n            new Timestamp(client.birthday().getTime()),\r\n            client.phoneNumber(),\r\n            new Timestamp(new Date().getTime()),\r\n            StatusUserEnum.INACTIVE\r\n        );\r\n\r\n        clientRepository.saveAndFlush(newClient);\r\n    }\r\n\r\n    /**\r\n     * Метод изменения мероприятия в избранном пользователя\r\n     * @param authorization токен авторизации\r\n     * @param id мероприятия\r\n     * @return id и измененный статус избранного\r\n     */\r\n    @Override\r\n    public FavoriteResponse toggleEventFavorite(String authorization, Long id) throws EntityNotFoundException {\r\n        log.trace(\"ClientServiceImpl.toggleEventFavorite - authorization {}, id {}\", authorization, id);\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Client client = clientRepository.findFirstByUser(user);\r\n        Event event = eventService.getEventById(id);\r\n\r\n        if (event == null) {\r\n            throw new EntityNotFoundException(\"There is no event with this id!\");\r\n        }\r\n\r\n        boolean eventFavorite = client.getEventSet().contains(event);\r\n\r\n        if (eventFavorite) {\r\n            client.getEventSet().remove(event);\r\n        } else {\r\n            client.addEvent(event);\r\n        }\r\n        clientRepository.save(client);\r\n\r\n        return new FavoriteResponse(\r\n                event.getId(),\r\n                !eventFavorite\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения массива мероприятий из таблицы избранное у пользователя\r\n     * @param authorization токен авторизации\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getFavorite(String authorization) {\r\n        log.trace(\"ClientServiceImpl.getFavorite - authorization {}\", authorization);\r\n\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Client client = clientRepository.findFirstByUser(user);\r\n\r\n        ArrayList<PublicEvent> publicEvents = new ArrayList<>();\r\n\r\n        client.getEventSet().forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(new PublicEvent(\r\n                    event.getId(),\r\n                    event.getEventBasicInformation().getName_rus(),\r\n                    event.getEventBasicInformation().getSymbolicName(),\r\n                    event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                    genres.toArray(String[]::new),\r\n                    event.getEventBasicInformation().getImg(),\r\n                    event.getEventBasicInformation().getTypeEventId().getType(),\r\n                    true\r\n            ));\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /**\r\n     * Метод получения клиента\r\n     * @param user почта пользователя\r\n     * @return клиент\r\n     */\r\n    @Override\r\n    public Client getClientByUser(Users user) {\r\n        return clientRepository.findFirstByUser(user);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/ClientServiceImpl.java b/src/main/java/biletka/main/service/Impl/ClientServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/ClientServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/ClientServiceImpl.java	
@@ -2,17 +2,19 @@
 
 import biletka.main.Utils.JwtTokenUtils;
 import biletka.main.dto.request.ClientRegistrationRequest;
+import biletka.main.dto.request.RatingClientRequest;
 import biletka.main.dto.response.FavoriteResponse;
+import biletka.main.dto.response.MessageCreateResponse;
 import biletka.main.dto.universal.MassivePublicEvent;
 import biletka.main.dto.universal.PublicEvent;
-import biletka.main.entity.Client;
-import biletka.main.entity.Event;
-import biletka.main.entity.Genre;
-import biletka.main.entity.Users;
+import biletka.main.entity.*;
 import biletka.main.enums.StatusUserEnum;
+import biletka.main.exception.ErrorMessage;
+import biletka.main.exception.InvalidDataException;
 import biletka.main.repository.ClientRepository;
 import biletka.main.service.ClientService;
 import biletka.main.service.EventService;
+import biletka.main.service.RatingService;
 import biletka.main.service.UserService;
 import jakarta.persistence.EntityNotFoundException;
 import lombok.RequiredArgsConstructor;
@@ -22,10 +24,7 @@
 
 import java.sql.Timestamp;
 import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.Set;
+import java.util.*;
 
 @Service
 @RequiredArgsConstructor(onConstructor = @__(@Lazy))
@@ -37,6 +36,7 @@
     @Lazy
     private final UserService userService;
     private final EventService eventService;
+    private final RatingService ratingService;
 
     /**
      * Метод добавления нового пользователя в бд
@@ -71,13 +71,7 @@
                 authorization.substring(7)
         );
 
-        Users user = userService.getUserByEmail(userEmail);
-
-        if (user == null) {
-            throw new EntityNotFoundException("A broken token!");
-        }
-
-        Client client = clientRepository.findFirstByUser(user);
+        Client client = tokenVerification(authorization);
         Event event = eventService.getEventById(id);
 
         if (event == null) {
@@ -108,17 +102,7 @@
     public MassivePublicEvent getFavorite(String authorization) {
         log.trace("ClientServiceImpl.getFavorite - authorization {}", authorization);
 
-        String userEmail = jwtTokenUtils.getUsernameFromToken(
-                authorization.substring(7)
-        );
-
-        Users user = userService.getUserByEmail(userEmail);
-
-        if (user == null) {
-            throw new EntityNotFoundException("A broken token!");
-        }
-
-        Client client = clientRepository.findFirstByUser(user);
+        Client client = tokenVerification(authorization);
 
         ArrayList<PublicEvent> publicEvents = new ArrayList<>();
 
@@ -135,7 +119,8 @@
                     genres.toArray(String[]::new),
                     event.getEventBasicInformation().getImg(),
                     event.getEventBasicInformation().getTypeEventId().getType(),
-                    true
+                    true,
+                    event.getEventWebWidget().getDescription()
             ));
         });
 
@@ -149,6 +134,56 @@
      */
     @Override
     public Client getClientByUser(Users user) {
+        log.trace("ClientServiceImpl.getClientByUser - user {}", user);
         return clientRepository.findFirstByUser(user);
     }
+
+    /**
+     * Метод изменения рейтинга мероприятия пользователем
+     * @param authorization токен авторизации
+     * @param ratingClientRequest информация для изменения рейтинга мероприятия
+     * @return успешное изменение
+     */
+    @Override
+    public MessageCreateResponse putRatingEvent(String authorization, RatingClientRequest ratingClientRequest) {
+        log.trace("ClientServiceImpl.putRatingEvent - authorization {}, ratingClientRequest {}", authorization, ratingClientRequest);
+
+        Client client = tokenVerification(authorization);
+
+        Event event = eventService.getEventByIdAndSymbolic(ratingClientRequest.eventSymbolic());
+
+        ratingService.createRating(client, event, ratingClientRequest.rating());
+
+        eventService.putRatingEvent(event, ratingClientRequest.rating());
+
+        return new MessageCreateResponse(
+                "The rating has been successfully set!"
+        );
+    }
+    /**
+     * Проверка токена авторизации и вывод пользователя
+     * @param token токен авторизации
+     * @return организация
+     */
+    public Client tokenVerification(String token) {
+        log.trace("ClientServiceImpl.tokenVerification - token {}", token);
+        String userEmail = jwtTokenUtils.getUsernameFromToken(
+                token.substring(7)
+        );
+
+        Users user = userService.getUserByEmail(userEmail);
+
+        if (user == null) {
+            throw new EntityNotFoundException("A broken token!");
+        }
+
+        Client client = clientRepository.findFirstByUser(user);
+
+        if (client == null) {
+            throw new EntityNotFoundException("A broken token!");
+        }
+
+        return client;
+    }
+
 }
Index: src/main/java/biletka/main/config/SecurityConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.config;\r\n\r\nimport biletka.main.Utils.PasswordEncoder;\r\nimport biletka.main.enums.RoleEnum;\r\nimport biletka.main.service.Impl.UserServiceImpl;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.http.HttpMethod;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\r\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\r\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\r\nimport org.springframework.security.config.http.SessionCreationPolicy;\r\nimport org.springframework.security.web.SecurityFilterChain;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\nimport org.springframework.web.cors.CorsConfiguration;\r\nimport org.springframework.web.cors.CorsConfigurationSource;\r\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\r\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\r\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\r\n\r\n@Configuration\r\n@EnableMethodSecurity\r\n@RequiredArgsConstructor\r\npublic class SecurityConfig {\r\n    private final PasswordEncoder passwordEncoder;\r\n    private final UserServiceImpl userService;\r\n    private final JwtRequestFilter jwtRequestFilter;\r\n\r\n    @Bean\r\n    public DaoAuthenticationProvider daoAuthenticationProvider() {\r\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\r\n        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder.getEncoder());\r\n        daoAuthenticationProvider.setUserDetailsService(userService);\r\n        return daoAuthenticationProvider;\r\n    }\r\n\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {\r\n        return authenticationConfiguration.getAuthenticationManager();\r\n    }\r\n\r\n    @Bean\r\n    public CorsConfigurationSource corsConfigurationSource() {\r\n        CorsConfiguration corsConfiguration = new CorsConfiguration();\r\n        corsConfiguration.addAllowedOrigin(\"*\");\r\n        corsConfiguration.addAllowedHeader(\"*\");\r\n        corsConfiguration.addAllowedMethod(\"*\");\r\n        corsConfiguration.setMaxAge(300000L);\r\n\r\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\r\n        source.registerCorsConfiguration(\"/**\", corsConfiguration);\r\n\r\n        return source;\r\n    }\r\n\r\n    @Bean\r\n    public WebMvcConfigurer corsMappingConfigurer() {\r\n        return new WebMvcConfigurer() {\r\n            @Override\r\n            public void addCorsMappings(CorsRegistry registry) {\r\n                registry.addMapping(\"/**\")\r\n                        .allowedOrigins(\"*\")\r\n                        .allowedMethods(\"*\")\r\n                        .allowedHeaders(\"*\")\r\n                        .exposedHeaders(\"*\");\r\n            }\r\n        };\r\n    }\r\n\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http\r\n                .cors(c -> c.configurationSource(corsConfigurationSource()))\r\n                .csrf(AbstractHttpConfigurer::disable)\r\n                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\r\n                .authorizeHttpRequests(auth -> auth\r\n                        .requestMatchers(HttpMethod.POST,\"/place\").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())\r\n                        .requestMatchers(HttpMethod.POST,\"/place/hall\").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())\r\n                        .requestMatchers(HttpMethod.POST,\"/event\").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())\r\n                        .requestMatchers(HttpMethod.POST,\"/session\").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())\r\n                        .requestMatchers(\"/client/**\").hasAuthority(RoleEnum.CLIENT.getAuthority())\r\n                        .anyRequest().permitAll()\r\n                );\r\n\r\n        http.authenticationProvider(daoAuthenticationProvider());\r\n        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);\r\n\r\n        return http.build();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/config/SecurityConfig.java b/src/main/java/biletka/main/config/SecurityConfig.java
--- a/src/main/java/biletka/main/config/SecurityConfig.java	
+++ b/src/main/java/biletka/main/config/SecurityConfig.java	
@@ -1,20 +1,27 @@
 package biletka.main.config;
 
+import biletka.main.Utils.IpAddressUtils;
 import biletka.main.Utils.PasswordEncoder;
 import biletka.main.enums.RoleEnum;
 import biletka.main.service.Impl.UserServiceImpl;
+import jakarta.servlet.http.HttpServletRequest;
 import lombok.RequiredArgsConstructor;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.http.HttpMethod;
 import org.springframework.security.authentication.AuthenticationManager;
 import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
+import org.springframework.security.authorization.AuthorizationDecision;
+import org.springframework.security.authorization.AuthorizationManager;
 import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
 import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
 import org.springframework.security.config.annotation.web.builders.HttpSecurity;
 import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
 import org.springframework.security.config.http.SessionCreationPolicy;
+import org.springframework.security.core.Authentication;
+import org.springframework.security.core.context.SecurityContextHolder;
 import org.springframework.security.web.SecurityFilterChain;
+import org.springframework.security.web.access.intercept.RequestAuthorizationContext;
 import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
 import org.springframework.web.cors.CorsConfiguration;
 import org.springframework.web.cors.CorsConfigurationSource;
@@ -22,6 +29,8 @@
 import org.springframework.web.servlet.config.annotation.CorsRegistry;
 import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
 
+import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole;
+
 @Configuration
 @EnableMethodSecurity
 @RequiredArgsConstructor
@@ -29,6 +38,7 @@
     private final PasswordEncoder passwordEncoder;
     private final UserServiceImpl userService;
     private final JwtRequestFilter jwtRequestFilter;
+    private final IpAddressUtils ipAddressUtils;
 
     @Bean
     public DaoAuthenticationProvider daoAuthenticationProvider() {
@@ -82,7 +92,10 @@
                         .requestMatchers(HttpMethod.POST,"/place/hall").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())
                         .requestMatchers(HttpMethod.POST,"/event").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())
                         .requestMatchers(HttpMethod.POST,"/session").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())
-                        .requestMatchers("/client/**").hasAuthority(RoleEnum.CLIENT.getAuthority())
+                        .requestMatchers("/client**").hasAuthority(RoleEnum.CLIENT.getAuthority())
+                        .requestMatchers("/organization**").hasAuthority(RoleEnum.ORGANIZATION.getAuthority())
+                        .requestMatchers(HttpMethod.POST, "/dGlja2V0QWRtaW4=" ).access(hasIpAddress())
+                        .requestMatchers(HttpMethod.POST, "/security/organization").hasAuthority(RoleEnum.ADMIN.getAuthority())
                         .anyRequest().permitAll()
                 );
 
@@ -91,4 +104,17 @@
 
         return http.build();
     }
+
+    private AuthorizationManager<RequestAuthorizationContext> hasIpAddress() {
+        return (authentication, context) -> {
+            boolean statusUser = false;
+            HttpServletRequest request = context.getRequest();
+
+            if (ipAddressUtils.checkIpAdministrator(request.getRemoteAddr())) {
+                statusUser = true;
+            }
+
+            return new AuthorizationDecision(statusUser);
+        };
+    }
 }
Index: src/main/java/biletka/main/service/Impl/UserServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.ActivationCode;\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.Utils.PasswordEncoder;\r\nimport biletka.main.dto.request.ActiveClientRequest;\r\nimport biletka.main.dto.request.AuthForm;\r\nimport biletka.main.dto.request.ClientRegistrationRequest;\r\nimport biletka.main.dto.request.OrganizationRegistrationRequest;\r\nimport biletka.main.dto.response.AuthResponse;\r\nimport biletka.main.dto.response.ClientRegistrationResponse;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.entity.Organization;\r\nimport biletka.main.entity.Users;\r\nimport biletka.main.enums.RoleEnum;\r\nimport biletka.main.enums.StatusUserEnum;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.UserRepository;\r\nimport biletka.main.service.ClientService;\r\nimport biletka.main.service.MailSender;\r\nimport biletka.main.service.OrganizationService;\r\nimport biletka.main.service.UserService;\r\nimport jakarta.mail.MessagingException;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport jakarta.transaction.Transactional;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.security.core.userdetails.User;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.text.ParseException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n@Service\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\n@Slf4j\r\npublic class UserServiceImpl implements UserService, UserDetailsService {\r\n    private final UserRepository userRepository;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final ActivationCode activationCode;\r\n\r\n    @Lazy\r\n    private final ClientService clientService;\r\n    private final MailSender mailSender;\r\n    @Lazy\r\n    private final OrganizationService organizationService;\r\n\r\n    /**\r\n     * Метод получения токена авторизации\r\n     * @param authForm форма аутентификации\r\n     * @return токен авторизации\r\n     */\r\n    @Override\r\n    @Transactional\r\n    public AuthResponse getAuthToken(AuthForm authForm) {\r\n        log.trace(\"UserServiceImpl.getAuthToken - authForm {}\", authForm);\r\n        Users user = userRepository.findFirstByEmail(authForm.email());\r\n\r\n        // Проверка на правильно введнные данные и не актвиный аккаунт\r\n        if (user == null ||\r\n                user.getStatus().getStatusUser().equalsIgnoreCase(\"INACTIVE\") ||\r\n                user.getStatus().getStatusUser().equalsIgnoreCase(\"ACTIVE\") &&\r\n                (\r\n                        !user.getRole().getAuthority().equalsIgnoreCase(authForm.role()) ||\r\n                        PasswordEncoder.arePasswordsEquals(user.getPassword(), authForm.password())\r\n                )\r\n        ) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Authentication error\", \"The email or password is incorrect!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n        // Проверка на бан аккаунта\r\n        else if (user.getStatus().getStatusUser().equalsIgnoreCase(\"BANNED\")) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Banned\", \"The account is banned!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        // Детали пользователя для токена\r\n        UserDetails userDetails = new User(\r\n                user.getEmail(),\r\n                user.getPassword(),\r\n                Collections.singleton(user.getRole())\r\n        );\r\n\r\n        return new AuthResponse(\r\n                jwtTokenUtils.generateToken(userDetails)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод сохранения нового пользователя в бд\r\n     * @param client данные пользователя\r\n     * @return сообщение о успешном создании пользователя\r\n     */\r\n    @Override\r\n    public ClientRegistrationResponse postNewUser(ClientRegistrationRequest client) throws ParseException, MessagingException {\r\n        log.trace(\"UserServiceImpl.postNewUser - client {}\", client);\r\n\r\n        Users user = userRepository.findFirstByEmail(client.email());\r\n\r\n        if (user != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Registration error\", \"This user already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        Users newUser = new Users(\r\n                client.email(),\r\n                PasswordEncoder.getEncryptedPassword(client.password()),\r\n                RoleEnum.CLIENT,\r\n                StatusUserEnum.INACTIVE,\r\n                activationCode.generateActivationCode()\r\n        );\r\n\r\n        userRepository.saveAndFlush(newUser);\r\n\r\n        clientService.postNewClient(client, newUser);\r\n\r\n        mailSender.activateEmailClient(newUser.getActiveCode(), newUser.getEmail());\r\n\r\n        return new ClientRegistrationResponse(\r\n                String.format(\"The user '\" + newUser.getEmail() + \"' has been created\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод сохранения нового организации в бд\r\n     * @param organizationRequest данные организации\r\n     * @return сообщение о успешном создании организации\r\n     */\r\n    @Override\r\n    public MessageCreateResponse postNewOrganization(OrganizationRegistrationRequest organizationRequest) {\r\n        log.trace(\"UserServiceImpl.postNewOrganization - organizationRequest {}\", organizationRequest);\r\n\r\n        Users user = userRepository.findFirstByEmail(organizationRequest.email());\r\n        Organization organization = organizationService.getOrganizationByFullNameOrganization(organizationRequest);\r\n\r\n        if (user != null || organization != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Registration error\", \"This user already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        Users newUser = new Users(\r\n                organizationRequest.email(),\r\n                PasswordEncoder.getEncryptedPassword(organizationRequest.password()),\r\n                RoleEnum.ORGANIZATION,\r\n                StatusUserEnum.ACTIVE,\r\n                activationCode.generateActivationCode()\r\n        );\r\n\r\n        userRepository.saveAndFlush(newUser);\r\n\r\n        organizationService.postCreateOrganization(organizationRequest, newUser);\r\n\r\n        return new MessageCreateResponse(\r\n                \"The organization '\" + organizationRequest.fullNameOrganization() + \"' has been created\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод активации пользователя с помощью кода\r\n     * @param activeClientRequest данные для активации\r\n     * @return сообщение о успешной активации\r\n     */\r\n    @Override\r\n    public ClientRegistrationResponse putActiveUser(ActiveClientRequest activeClientRequest) {\r\n        log.trace(\"UserServiceImpl.putActiveUser - activeClientRequest {}\", activeClientRequest);\r\n        Users user = userRepository.findFirstByEmail(activeClientRequest.email());\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"Entity with email \" + activeClientRequest.email() + \" not found\");\r\n        } else if (user.getStatus() == StatusUserEnum.ACTIVE) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Activation error\", \"The account has already been activated!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        user.setStatus(StatusUserEnum.ACTIVE);\r\n        userRepository.save(user);\r\n\r\n        return new ClientRegistrationResponse(\"The account '\" + user.getEmail() + \"' is activated\");\r\n    }\r\n\r\n    /**\r\n     * Метод получения пользователя по почте\r\n     * @param userEmail почта пользователя\r\n     * @return данные пользователя\r\n     */\r\n    @Override\r\n    public Users getUserByEmail(String userEmail) {\r\n        log.trace(\"UserServiceImpl.getUserByEmail - userEmail {}\", userEmail);\r\n        Users user = userRepository.findFirstByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"Entity with email \" + userEmail + \" not found\");\r\n        }\r\n\r\n        return user;\r\n    }\r\n\r\n    /**\r\n     * Метод получения пользователя организации по почте\r\n     * @param userEmail почта пользователя\r\n     * @return данные пользователя\r\n     */\r\n    @Override\r\n    public Users getUserOrganizationByEmail(String userEmail) {\r\n        log.trace(\"UserServiceImpl.getUserOrganizationByEmail - userEmail {}\", userEmail);\r\n        Users user = userRepository.findFirstByEmail(userEmail);\r\n\r\n        if (user == null || user.getRole() != RoleEnum.ORGANIZATION) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        return user;\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException, EntityNotFoundException {\r\n        log.trace(\"UserServiceImpl.loadUserByUsername - email {}\", email);\r\n\r\n        Users user = userRepository.findFirstByEmail(email);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"Entity with email \" + email + \" not found\");\r\n        }\r\n\r\n        return new User(\r\n                user.getEmail(),\r\n                user.getPassword(),\r\n                Collections.singleton(user.getRole())\r\n        );\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/UserServiceImpl.java b/src/main/java/biletka/main/service/Impl/UserServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/UserServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/UserServiceImpl.java	
@@ -10,6 +10,7 @@
 import biletka.main.dto.response.AuthResponse;
 import biletka.main.dto.response.ClientRegistrationResponse;
 import biletka.main.dto.response.MessageCreateResponse;
+import biletka.main.entity.Administrator;
 import biletka.main.entity.Organization;
 import biletka.main.entity.Users;
 import biletka.main.enums.RoleEnum;
@@ -17,10 +18,7 @@
 import biletka.main.exception.ErrorMessage;
 import biletka.main.exception.InvalidDataException;
 import biletka.main.repository.UserRepository;
-import biletka.main.service.ClientService;
-import biletka.main.service.MailSender;
-import biletka.main.service.OrganizationService;
-import biletka.main.service.UserService;
+import biletka.main.service.*;
 import jakarta.mail.MessagingException;
 import jakarta.persistence.EntityNotFoundException;
 import jakarta.transaction.Transactional;
@@ -48,6 +46,11 @@
 
     @Lazy
     private final ClientService clientService;
+<<<<<<< HEAD
+=======
+    private final OrganizationService organizationService;
+    private final AdministratorService administratorService;
+>>>>>>> d6c3ff77687d3488060dffd5cec397f35a529e4c
     private final MailSender mailSender;
     @Lazy
     private final OrganizationService organizationService;
@@ -232,6 +235,14 @@
         Users user = userRepository.findFirstByEmail(email);
 
         if (user == null) {
+            if (administratorService.getAdminByEmail(email) != null) {
+                Administrator administrator = administratorService.getAdminByEmail(email);
+                return new User(
+                        administrator.getEmail(),
+                        administrator.getPassword(),
+                        Collections.singleton(administrator.getRole())
+                );
+            }
             throw new EntityNotFoundException("Entity with email " + email + " not found");
         }
 
Index: src/main/java/biletka/main/repository/GenreRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.repository;\r\n\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport biletka.main.entity.Genre;\r\npublic interface GenreRepository extends JpaRepository<Genre, Long>{\r\n    Genre findFirstByName(String name);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/repository/GenreRepository.java b/src/main/java/biletka/main/repository/GenreRepository.java
--- a/src/main/java/biletka/main/repository/GenreRepository.java	
+++ b/src/main/java/biletka/main/repository/GenreRepository.java	
@@ -2,6 +2,9 @@
 
 import org.springframework.data.jpa.repository.JpaRepository;
 import biletka.main.entity.Genre;
+
+import java.util.List;
+
 public interface GenreRepository extends JpaRepository<Genre, Long>{
     Genre findFirstByName(String name);
 }
Index: src/main/java/biletka/main/dto/response/TotalSession/SessionResponse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/response/TotalSession/SessionResponse.java b/src/main/java/biletka/main/dto/response/TotalSession/SessionResponse.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/biletka/main/dto/response/TotalSession/SessionResponse.java	
@@ -0,0 +1,16 @@
+package biletka.main.dto.response.TotalSession;
+
+import jakarta.persistence.Column;
+
+import java.sql.Timestamp;
+
+public record SessionResponse(
+    Integer sales,
+    Integer onSales,
+    Timestamp startTime,
+    Timestamp finishTime,
+    Integer numberOfViews,
+    Double price,
+    Boolean status
+) {
+}
Index: src/main/java/biletka/main/dto/response/TotalSession/PlacesByOrganization.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/response/TotalSession/PlacesByOrganization.java b/src/main/java/biletka/main/dto/response/TotalSession/PlacesByOrganization.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/biletka/main/dto/response/TotalSession/PlacesByOrganization.java	
@@ -0,0 +1,18 @@
+package biletka.main.dto.response.TotalSession;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+public record PlacesByOrganization(
+        @JsonProperty("place_name")
+        String placeName,
+
+        @JsonProperty("city_name")
+        String cityName,
+
+        @JsonProperty("place_address")
+        String placeAddress,
+
+        @JsonProperty("events")
+        EventsByPlace[] eventsByPlace
+) {
+}
Index: src/main/java/biletka/main/dto/response/TotalSession/TotalSession.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/response/TotalSession/TotalSession.java b/src/main/java/biletka/main/dto/response/TotalSession/TotalSession.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/biletka/main/dto/response/TotalSession/TotalSession.java	
@@ -0,0 +1,6 @@
+package biletka.main.dto.response.TotalSession;
+
+public record TotalSession(
+        PlacesByOrganization[] placesByOrganization
+) {
+}
Index: src/main/java/biletka/main/dto/response/EventResponse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/response/EventResponse.java b/src/main/java/biletka/main/dto/response/EventResponse.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/biletka/main/dto/response/EventResponse.java	
@@ -0,0 +1,24 @@
+package biletka.main.dto.response;
+
+import biletka.main.entity.Genre;
+import biletka.main.entity.Tag;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+
+public record EventResponse(
+    Long Id,
+    String symbolicName,
+    String name_rus,
+    Double rating,
+    String description,
+    String type_event,
+    int ageRating,
+    String[] genres,
+    String author,
+    String writerOrArtist,
+    String duration,
+    String[] tags,
+    Boolean pushkin
+)
+{
+}
Index: src/main/resources/application.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#DATABASE\r\nspring.datasource.url=jdbc:postgresql://localhost:5432/Biletka\r\nspring.datasource.username=postgres\r\nspring.datasource.password=klmsdpre\r\nspring.datasource.hikari.auto-commit=false\r\n#JPA\r\nspring.jpa.generate-ddl=true\r\nspring.jpa.hibernate.ddl-auto=update\r\n#LIQUIBASE\r\nspring.liquibase.enabled=false\r\n#SECURITY\r\nserver.port=8443\r\nserver.ssl.enabled=false\r\nserver.ssl.key-store-password=Biletka\r\nserver.ssl.key-store-type=PKCS12\r\nserver.ssl.key-store=classpath:ssl/certificate.p12\r\napp.secret-key=8gshagaswtnqbt89faufqtdagdgasdgds\r\napp.key-lifetime-minutes=20m\r\napplication.authorization.path=/security\r\n#APPLICATION\r\napplication.email.address=info@biletka.com\r\napplication.server.address=https://ticket-zone.ru\r\n#MAIL SENDER\r\nspring.mail.host=mail.hosting.reg.ru\r\nspring.mail.username=edin_bilet@ticket-zone.ru\r\nspring.mail.password=iZ2sJ7pE7fnY1sY0\r\nspring.mail.port=465\r\n#spring.mail.port=587\r\nspring.mail.protocol=smtp\r\nspring.mail.test-connection=true\r\nspring.mail.properties.mail.smtp.auth=true\r\nspring.mail.properties.mail.smtp.starttls.enable=true\r\nmail.smtp.starttls.enable=true\r\nmail.smtp.ssl.enable=true\r\nmail.debug=true\r\n#FILE\r\nspring.servlet.multipart.max-file-size=50MB\r\nspring.servlet.multipart.max-request-size=50MB\r\n#app.file.directory=/var/tmp/\r\napp.file.directory=D:/work/img/
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/src/main/resources/application.properties b/src/main/resources/application.properties
--- a/src/main/resources/application.properties	
+++ b/src/main/resources/application.properties	
@@ -5,9 +5,10 @@
 spring.datasource.hikari.auto-commit=false
 #JPA
 spring.jpa.generate-ddl=true
-spring.jpa.hibernate.ddl-auto=update
+spring.jpa.hibernate.ddl-auto=validate
 #LIQUIBASE
-spring.liquibase.enabled=false
+spring.liquibase.enabled=true
+spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.xml
 #SECURITY
 server.port=8443
 server.ssl.enabled=false
Index: src/main/java/biletka/main/dto/response/TotalSession/EventsByPlace.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/response/TotalSession/EventsByPlace.java b/src/main/java/biletka/main/dto/response/TotalSession/EventsByPlace.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/biletka/main/dto/response/TotalSession/EventsByPlace.java	
@@ -0,0 +1,15 @@
+package biletka.main.dto.response.TotalSession;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+public record EventsByPlace(
+        @JsonProperty("event_name")
+        String eventName,
+
+        @JsonProperty("type")
+        String type,
+
+        @JsonProperty("sessions")
+        SessionResponse[] sessions
+) {
+}
Index: src/main/java/biletka/main/dto/request/SessionCreateRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.dto.request;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport org.springframework.validation.annotation.Validated;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n@Validated\r\npublic record SessionCreateRequest(\r\n        @JsonProperty(\"start_time\")\r\n        LocalDateTime startTime,\r\n\r\n        @JsonProperty(\"price\")\r\n        Double price,\r\n\r\n        @JsonProperty(\"event_id\")\r\n        Long eventId,\r\n\r\n        @JsonProperty(\"hall_id\")\r\n        Long hallId,\r\n\r\n        @JsonProperty(\"type_of_movie\")\r\n        String typeOfMovie\r\n) {\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/dto/request/SessionCreateRequest.java b/src/main/java/biletka/main/dto/request/SessionCreateRequest.java
--- a/src/main/java/biletka/main/dto/request/SessionCreateRequest.java	
+++ b/src/main/java/biletka/main/dto/request/SessionCreateRequest.java	
@@ -1,6 +1,8 @@
 package biletka.main.dto.request;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
+import jakarta.validation.constraints.NotBlank;
+import jakarta.validation.constraints.NotNull;
 import org.springframework.validation.annotation.Validated;
 
 import java.time.LocalDateTime;
@@ -8,18 +10,23 @@
 @Validated
 public record SessionCreateRequest(
         @JsonProperty("start_time")
+        @NotNull(message = "Start time is mandatory!")
         LocalDateTime startTime,
 
         @JsonProperty("price")
+        @NotNull(message = "Price is mandatory!")
         Double price,
 
         @JsonProperty("event_id")
+        @NotNull(message = "Event id is mandatory!")
         Long eventId,
 
         @JsonProperty("hall_id")
+        @NotNull(message = "Hall is mandatory!")
         Long hallId,
 
         @JsonProperty("type_of_movie")
+        @NotBlank(message = "Type of movie is mandatory!")
         String typeOfMovie
 ) {
 }
Index: src/main/java/biletka/main/service/HallService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.dto.request.HallCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.entity.Hall;\r\nimport jakarta.mail.MessagingException;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\n@Service\r\npublic interface HallService {\r\n    /**\r\n     * Метод создания зала площадки без схемы (требуется подтверждение администратор)\r\n     * @param authorization токен авторизации\r\n     * @param file схема зала\r\n     * @param hallCreateRequestNew информация о зале\r\n     * @return сообщение о успешном создании зала\r\n     */\r\n    MessageCreateResponse createHall(String authorization, MultipartFile file, HallCreateRequest hallCreateRequestNew) throws MessagingException;\r\n\r\n    /**\r\n     * Метод получения зала по id\r\n     * @param id зала\r\n     * @return зал\r\n     */\r\n    Hall getHallById(Long id);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/HallService.java b/src/main/java/biletka/main/service/HallService.java
--- a/src/main/java/biletka/main/service/HallService.java	
+++ b/src/main/java/biletka/main/service/HallService.java	
@@ -3,10 +3,13 @@
 import biletka.main.dto.request.HallCreateRequest;
 import biletka.main.dto.response.MessageCreateResponse;
 import biletka.main.entity.Hall;
+import biletka.main.entity.Place;
 import jakarta.mail.MessagingException;
 import org.springframework.stereotype.Service;
 import org.springframework.web.multipart.MultipartFile;
 
+import java.util.Set;
+
 @Service
 public interface HallService {
     /**
@@ -24,4 +27,18 @@
      * @return зал
      */
     Hall getHallById(Long id);
+
+    /**
+     * Метод получения количества залов в площадке
+     * @param place площадка
+     * @return количество залов
+     */
+    Integer getTotalByPlace(Place place);
+
+    /**
+     * Метод получения массива залов по площадке
+     * @param place площадка
+     * @return массив залов
+     */
+    Set<Hall> getAllHallByPlace(Place place);
 }
Index: src/main/java/biletka/main/repository/HallRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.repository;\r\n\r\nimport biletka.main.entity.Hall;\r\nimport biletka.main.entity.Place;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\n@Repository\r\npublic interface HallRepository extends JpaRepository<Hall, Long> {\r\n    Hall findFirstByPlaceAndHallNumber(Place place, Integer hallNumber);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/repository/HallRepository.java b/src/main/java/biletka/main/repository/HallRepository.java
--- a/src/main/java/biletka/main/repository/HallRepository.java	
+++ b/src/main/java/biletka/main/repository/HallRepository.java	
@@ -3,9 +3,21 @@
 import biletka.main.entity.Hall;
 import biletka.main.entity.Place;
 import org.springframework.data.jpa.repository.JpaRepository;
+import org.springframework.data.jpa.repository.Query;
 import org.springframework.stereotype.Repository;
 
+import java.util.Set;
+
 @Repository
 public interface HallRepository extends JpaRepository<Hall, Long> {
     Hall findFirstByPlaceAndHallNumber(Place place, Integer hallNumber);
+
+    @Query("SELECT COUNT(h) FROM Hall h " +
+            "WHERE h.place = :place")
+    Integer findTotalByPlace(Place place);
+
+    @Query("SELECT h FROM Hall h " +
+            "WHERE h.place = :place " +
+            "ORDER BY h.hallNumber")
+    Set<Hall> findAllByPlace(Place place);
 }
Index: src/main/java/biletka/main/service/Impl/HallServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.FileUtils;\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.HallCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.entity.Hall;\r\nimport biletka.main.entity.Organization;\r\nimport biletka.main.entity.Place;\r\nimport biletka.main.entity.Users;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.HallRepository;\r\nimport biletka.main.service.*;\r\nimport jakarta.mail.MessagingException;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class HallServiceImpl implements HallService {\r\n    private final HallRepository hallRepository;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final MailSender mailSender;\r\n    private final FileUtils fileUtils;\r\n\r\n    private final UserService userService;\r\n    private final OrganizationService organizationService;\r\n    private final PlaceService placeService;\r\n\r\n    /**\r\n     * Метод создания зала площадки без схемы (требуется подтверждение администратор)\r\n     * @param authorization токен авторизации\r\n     * @param file схема зала\r\n     * @param hallCreateRequestNew информация о зале\r\n     * @return сообщение о успешном создании зала\r\n     */\r\n    @Override\r\n    public MessageCreateResponse createHall(String authorization, MultipartFile file, HallCreateRequest hallCreateRequestNew) throws MessagingException, EntityNotFoundException {\r\n        log.trace(\"HallServiceImpl.createHall - authorization {}, file {}, hallCreateRequestNew {}\", authorization, file, hallCreateRequestNew);\r\n        String typeFile = fileUtils.getFileExtension(file.getOriginalFilename());\r\n\r\n        fileUtils.validationFile(\r\n                typeFile,\r\n                new String[]{\"svg\"}\r\n        );\r\n\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = organizationService.getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Place place = placeService.getPlaceById(hallCreateRequestNew.placeId());\r\n\r\n        if (!organization.getPlaceSet().contains(place)) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Hall hall = hallRepository.findFirstByPlaceAndHallNumber(place, hallCreateRequestNew.hallNumber());\r\n\r\n        if (hall != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Create hall error\", \"This hall already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        hall = new Hall(\r\n                hallCreateRequestNew.hallNumber(),\r\n                hallCreateRequestNew.hallName(),\r\n                hallCreateRequestNew.numberOfSeats(),\r\n                hallCreateRequestNew.info(),\r\n                hallCreateRequestNew.seatGroupInfo(),\r\n                null,\r\n                place\r\n        );\r\n\r\n        hallRepository.saveAndFlush(hall);\r\n\r\n        mailSender.sendHall(file, hall.getId());\r\n\r\n        return new MessageCreateResponse(\r\n                \"The hall has been successfully created! Display wait for the administrator to check!\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения зала по id\r\n     * @param id зала\r\n     * @return зал\r\n     */\r\n    @Override\r\n    public Hall getHallById(Long id) {\r\n        log.trace(\"HallServiceImpl.getHallById - id {}\", id);\r\n        return hallRepository.getReferenceById(id);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/HallServiceImpl.java b/src/main/java/biletka/main/service/Impl/HallServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/HallServiceImpl.java	
+++ b/src/main/java/biletka/main/service/Impl/HallServiceImpl.java	
@@ -21,6 +21,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 @Service
 @RequiredArgsConstructor
@@ -111,4 +112,26 @@
         log.trace("HallServiceImpl.getHallById - id {}", id);
         return hallRepository.getReferenceById(id);
     }
+
+    /**
+     * Метод получения количества залов в площадке
+     * @param place площадка
+     * @return количество залов
+     */
+    @Override
+    public Integer getTotalByPlace(Place place) {
+        log.trace("HallServiceImpl.getHallById - place {}", place);
+        return hallRepository.findTotalByPlace(place);
+    }
+
+    /**
+     * Метод получения массива залов по площадке
+     * @param place площадка
+     * @return массив залов
+     */
+    @Override
+    public Set<Hall> getAllHallByPlace(Place place) {
+        log.trace("HallServiceImpl.getAllHallByPlace - place {}", place);
+        return hallRepository.findAllByPlace(place);
+    }
 }
Index: src/main/java/biletka/main/controller/ClientController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.controller;\r\n\r\nimport biletka.main.dto.response.FavoriteResponse;\r\nimport biletka.main.dto.universal.MassivePublicEvent;\r\nimport biletka.main.service.ClientService;\r\nimport io.swagger.v3.oas.annotations.Operation;\r\nimport io.swagger.v3.oas.annotations.Parameter;\r\nimport io.swagger.v3.oas.annotations.tags.Tag;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n@Slf4j\r\n@RestController\r\n@RequestMapping(\"/client\")\r\n@RequiredArgsConstructor\r\n@Tag(name = \"Контроллер клиентов\", description = \"Всё, что связано с клиентами\")\r\npublic class ClientController {\r\n    private final ClientService clientService;\r\n\r\n    @Operation(\r\n            summary = \"Изменение избранного для пользователя\",\r\n            description = \"Позволяет изменить мероприятие в избранном пользователю\"\r\n    )\r\n    @PutMapping(\"/favorite\")\r\n    public ResponseEntity<?> putEventInClient(@Parameter(description = \"токен пользователя\") @RequestHeader(\"Authorization\") String authorization,\r\n                                              @Parameter(description = \"id мероприятия\") @RequestParam Long id) {\r\n        log.trace(\"ClientController.putEventInClient - authorization {}, id {}\", authorization, id);\r\n        FavoriteResponse favoriteResponse = clientService.toggleEventFavorite(authorization, id);\r\n\r\n        return ResponseEntity.accepted().body(favoriteResponse);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Получение массива избранного\",\r\n            description = \"Позовляет получить массив мероприятий у избранного пользователя\"\r\n    )\r\n    @GetMapping(\"/favorite\")\r\n    public ResponseEntity<MassivePublicEvent> getFavorite(@Parameter(description = \"токен пользователя\") @RequestHeader(\"Authorization\") String authorization) {\r\n        log.trace(\"ClientController.getFavorite - authorization {}\", authorization);\r\n        MassivePublicEvent massivePublicEvent = clientService.getFavorite(authorization);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/controller/ClientController.java b/src/main/java/biletka/main/controller/ClientController.java
--- a/src/main/java/biletka/main/controller/ClientController.java	
+++ b/src/main/java/biletka/main/controller/ClientController.java	
@@ -1,6 +1,8 @@
 package biletka.main.controller;
 
+import biletka.main.dto.request.RatingClientRequest;
 import biletka.main.dto.response.FavoriteResponse;
+import biletka.main.dto.response.MessageCreateResponse;
 import biletka.main.dto.universal.MassivePublicEvent;
 import biletka.main.service.ClientService;
 import io.swagger.v3.oas.annotations.Operation;
@@ -10,6 +12,7 @@
 import lombok.extern.slf4j.Slf4j;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.ResponseEntity;
+import org.springframework.validation.annotation.Validated;
 import org.springframework.web.bind.annotation.*;
 
 @Slf4j
@@ -43,4 +46,16 @@
         MassivePublicEvent massivePublicEvent = clientService.getFavorite(authorization);
         return ResponseEntity.ok(massivePublicEvent);
     }
+
+    @Operation(
+            summary = "Оценка мероприятия",
+            description = "Позволяет оценить мероприятие пользователю"
+    )
+    @PutMapping("/rating")
+    public ResponseEntity<MessageCreateResponse> putRatingEvent(@Parameter(description = "токен пользователя") @RequestHeader("Authorization") String authorization,
+                                                                @Parameter(description = "информация для оценивание мероприятия пользователем") @Validated @RequestBody RatingClientRequest ratingClientRequest) {
+        log.trace("ClientController.putRatingEvent - authorization {}, ratingClientRequest {}", authorization, ratingClientRequest);
+        MessageCreateResponse messageCreateResponse = clientService.putRatingEvent(authorization, ratingClientRequest);
+        return ResponseEntity.status(HttpStatus.ACCEPTED).body(messageCreateResponse);
+    }
 }
diff --git a/.gradle/8.7/gc.properties b/.gradle/8.7/gc.properties
new file mode 100644
diff --git a/.gradle/vcs-1/gc.properties b/.gradle/vcs-1/gc.properties
new file mode 100644
diff --git a/.gradle/8.7/dependencies-accessors/gc.properties b/.gradle/8.7/dependencies-accessors/gc.properties
new file mode 100644
