Index: build/resources/main/application.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#DATABASE\r\nspring.datasource.url=jdbc:postgresql://localhost:5432/Biletka\r\nspring.datasource.username=postgres\r\nspring.datasource.password=klmsdpre\r\nspring.datasource.hikari.auto-commit=false\r\n#JPA\r\nspring.jpa.generate-ddl=true\r\nspring.jpa.hibernate.ddl-auto=update\r\n#LIQUIBASE\r\nspring.liquibase.enabled=false\r\n#SECURITY\r\nserver.port=8443\r\nserver.ssl.enabled=false\r\nserver.ssl.key-store-password=Biletka\r\nserver.ssl.key-store-type=PKCS12\r\nserver.ssl.key-store=classpath:ssl/certificate.p12\r\napp.secret-key=8gshagaswtnqbt89faufqtdagdgasdgds\r\napp.key-lifetime-minutes=20m\r\napplication.authorization.path=/security\r\n#APPLICATION\r\napplication.email.address=info@biletka.com\r\napplication.server.address=https://ticket-zone.ru\r\n#MAIL SENDER\r\nspring.mail.host=mail.hosting.reg.ru\r\nspring.mail.username=edin_bilet@ticket-zone.ru\r\nspring.mail.password=iZ2sJ7pE7fnY1sY0\r\nspring.mail.port=465\r\n#spring.mail.port=587\r\nspring.mail.protocol=smtp\r\nspring.mail.test-connection=true\r\nspring.mail.properties.mail.smtp.auth=true\r\nspring.mail.properties.mail.smtp.starttls.enable=true\r\nmail.smtp.starttls.enable=true\r\nmail.smtp.ssl.enable=true\r\nmail.debug=true\r\n#FILE\r\nspring.servlet.multipart.max-file-size=50MB\r\nspring.servlet.multipart.max-request-size=50MB\r\n#app.file.directory=/var/tmp/\r\napp.file.directory=E:/work_img/
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/build/resources/main/application.properties b/build/resources/main/application.properties
--- a/build/resources/main/application.properties	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/build/resources/main/application.properties	(date 1715683143890)
@@ -37,4 +37,4 @@
 spring.servlet.multipart.max-file-size=50MB
 spring.servlet.multipart.max-request-size=50MB
 #app.file.directory=/var/tmp/
-app.file.directory=E:/work_img/
\ No newline at end of file
+app.file.directory=D:/work/img/
\ No newline at end of file
Index: src/main/java/biletka/main/MainApplication.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class MainApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(MainApplication.class, args);\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/MainApplication.java b/src/main/java/biletka/main/MainApplication.java
--- a/src/main/java/biletka/main/MainApplication.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/MainApplication.java	(date 1715356345785)
@@ -1,13 +1,24 @@
 package biletka.main;
 
+import biletka.main.dto.request.event_item.EventAdditional;
+import biletka.main.entity.Actor;
+import biletka.main.entity.Event;
+import biletka.main.entity.event_item.EventAdditionalInformation;
+import biletka.main.entity.event_item.EventWebWidget;
+import biletka.main.service.EventAdditionalInformationService;
+import biletka.main.service.EventService;
+import jakarta.persistence.Column;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.SpringBootApplication;
 
+import java.util.HashSet;
+import java.util.Set;
+
+
 @SpringBootApplication
 public class MainApplication {
 
 	public static void main(String[] args) {
 		SpringApplication.run(MainApplication.class, args);
 	}
-
 }
Index: src/main/java/biletka/main/service/ActorService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.entity.Actor;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic interface ActorService {\r\n    /**\r\n     * Метод получения актёра\r\n     * @param name имя актёра\r\n     * @return актёр\r\n     */\r\n    Actor getActorOfName(String name);\r\n\r\n    /**\r\n     * Метод создания актёра\r\n     * @param name ФИО актера\r\n     * @return актёр\r\n     */\r\n\r\n    Actor postNewActor(String name);\r\n    Actor createActor(String name);\r\n\r\n    Actor postNewActor(String name);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/ActorService.java b/src/main/java/biletka/main/service/ActorService.java
--- a/src/main/java/biletka/main/service/ActorService.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/service/ActorService.java	(date 1715683113499)
@@ -21,5 +21,4 @@
     Actor postNewActor(String name);
     Actor createActor(String name);
 
-    Actor postNewActor(String name);
 }
Index: src/main/java/biletka/main/controller/OrganizationController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.controller;\r\n\r\nimport biletka.main.dto.response.EventResponse;\r\nimport biletka.main.dto.response.OrganizationResponse;\r\nimport biletka.main.service.OrganizationService;\r\nimport io.swagger.v3.oas.annotations.Operation;\r\nimport io.swagger.v3.oas.annotations.Parameter;\r\nimport io.swagger.v3.oas.annotations.tags.Tag;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n@Slf4j\r\n@RestController\r\n@RequestMapping(\"/organization\")\r\n@RequiredArgsConstructor\r\n@Tag(name = \"Контроллер организация\", description = \"Всё, что связано с организациями\")\r\npublic class OrganizationController {\r\n    private final OrganizationService organizationService;\r\n\r\n    @Operation(\r\n            summary = \"Получение организации\",\r\n            description = \"Позволяет получить организацию по токену\"\r\n    )\r\n    @GetMapping\r\n    public ResponseEntity<OrganizationResponse> getOrganization(@Parameter(description = \"токен пользователя\") @RequestHeader(\"Authorization\") String authorization){\r\n        System.out.println(organizationService.getOrganization(authorization));\r\n        return ResponseEntity.status(HttpStatus.OK).body(organizationService.getOrganization(authorization));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/controller/OrganizationController.java b/src/main/java/biletka/main/controller/OrganizationController.java
--- a/src/main/java/biletka/main/controller/OrganizationController.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/controller/OrganizationController.java	(date 1716129970665)
@@ -1,6 +1,6 @@
 package biletka.main.controller;
 
-import biletka.main.dto.response.EventResponse;
+import biletka.main.dto.response.MassiveTotalSessions;
 import biletka.main.dto.response.OrganizationResponse;
 import biletka.main.service.OrganizationService;
 import io.swagger.v3.oas.annotations.Operation;
@@ -29,4 +29,13 @@
         System.out.println(organizationService.getOrganization(authorization));
         return ResponseEntity.status(HttpStatus.OK).body(organizationService.getOrganization(authorization));
     }
+
+    @Operation(
+            summary = "Получение организации",
+            description = "Позволяет получить организацию по токену"
+    )
+    public ResponseEntity<MassiveTotalSessions> getSessionSumByPlace(@Parameter(description = "токен пользователя") @RequestHeader("Authorization") String authorization){
+
+        return ResponseEntity.status(HttpStatus.OK).body(organizationService.getSessionSumByPlace(authorization));
+    }
 }
Index: src/main/java/biletka/main/repository/ClientRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.repository;\r\n\r\nimport biletka.main.entity.Client;\r\nimport biletka.main.entity.Users;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\n@Repository\r\npublic interface ClientRepository extends JpaRepository<Client, Long> {\r\n    Client findFirstByUser(Users user);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/repository/ClientRepository.java b/src/main/java/biletka/main/repository/ClientRepository.java
--- a/src/main/java/biletka/main/repository/ClientRepository.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/repository/ClientRepository.java	(date 1715779786367)
@@ -3,9 +3,13 @@
 import biletka.main.entity.Client;
 import biletka.main.entity.Users;
 import org.springframework.data.jpa.repository.JpaRepository;
+import org.springframework.data.jpa.repository.Query;
 import org.springframework.stereotype.Repository;
 
 @Repository
 public interface ClientRepository extends JpaRepository<Client, Long> {
+
+    //@Query("SELECT c FROM Client c " +
+      //      "WHERE c.user = :user ")
     Client findFirstByUser(Users user);
 }
Index: src/main/java/biletka/main/entity/event_item/EventBasicInformation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.entity.event_item;\r\n\r\nimport biletka.main.entity.AgeRating;\r\nimport biletka.main.entity.Genre;\r\nimport biletka.main.entity.TypeEvent;\r\nimport jakarta.persistence.*;\r\nimport lombok.Data;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n@Data\r\n@Entity\r\n@Table(name = \"event_basic_information\")\r\npublic class EventBasicInformation {\r\n    @Id\r\n    @Column(name = \"id\")\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @Column(name = \"name\")\r\n    private String name;\r\n\r\n    @Column(name = \"symbolic_name\")\r\n    private String symbolicName;\r\n\r\n    @Column(name = \"name_rus\")\r\n    private String name_rus;\r\n\r\n    @Column(name = \"organizaer\")\r\n    private String organizaer;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"age_id\")\r\n    private AgeRating ageRatingId;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name= \"type_id\")\r\n    private TypeEvent typeEventId;\r\n\r\n    @Column(name = \"pushkin\")\r\n    private Boolean pushkin;\r\n\r\n    @Column(name = \"event_id_culture\")\r\n    private Long eventIdCulture;\r\n\r\n    @Column(name = \"show_in_poster\")\r\n    private Boolean showInPoster;\r\n\r\n    @Column(name = \"img\")\r\n    private String img;\r\n\r\n    @ManyToMany\r\n    @JoinTable(\r\n            name = \"event_genre\",\r\n            joinColumns = @JoinColumn(name = \"basic_information_id\"),\r\n            inverseJoinColumns = @JoinColumn(name = \"genre_id\")\r\n    )\r\n    private Set<Genre> genres = new HashSet<>();\r\n\r\n    public void addGenres(Genre genre) {\r\n        if (genres == null) genres = new HashSet<>();\r\n        if (genre != null) this.genres.add(genre);\r\n    }\r\n\r\n    public EventBasicInformation() {\r\n    }\r\n\r\n    public EventBasicInformation(String name, String symbolicName, String name_rus, String organizaer, AgeRating ageRatingId, TypeEvent typeEventId, Boolean pushkin, Long eventIdCulture, Boolean showInPoster, String img, Set<Genre> genres) {\r\n        this.name = name;\r\n        this.symbolicName = symbolicName;\r\n        this.name_rus = name_rus;\r\n        this.organizaer = organizaer;\r\n        this.ageRatingId = ageRatingId;\r\n        this.typeEventId = typeEventId;\r\n        this.pushkin = pushkin;\r\n        this.eventIdCulture = eventIdCulture;\r\n        this.showInPoster = showInPoster;\r\n        this.img = img;\r\n        this.genres = genres;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/entity/event_item/EventBasicInformation.java b/src/main/java/biletka/main/entity/event_item/EventBasicInformation.java
--- a/src/main/java/biletka/main/entity/event_item/EventBasicInformation.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/entity/event_item/EventBasicInformation.java	(date 1715687855364)
@@ -58,6 +58,7 @@
     )
     private Set<Genre> genres = new HashSet<>();
 
+
     public void addGenres(Genre genre) {
         if (genres == null) genres = new HashSet<>();
         if (genre != null) this.genres.add(genre);
Index: src/main/java/biletka/main/service/Impl/SessionServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.SessionCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.entity.*;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.SessionRepository;\r\nimport biletka.main.service.*;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.sql.Timestamp;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\nimport java.time.ZoneId;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\n@Service\r\n@Slf4j\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\npublic class SessionServiceImpl implements SessionService {\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final SessionRepository sessionRepository;\r\n\r\n    private final UserService userService;\r\n    private final OrganizationService organizationService;\r\n    @Lazy\r\n    private final EventService eventService;\r\n    private final HallService hallService;\r\n    private final TypeOfMovieService typeOfMovieService;\r\n\r\n    /**\r\n     * Метод создания и сохранения сеанса мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param sessionCreateRequest информация о сеансе\r\n     * @return о успешном создании сеанса\r\n     */\r\n    @Override\r\n    public MessageCreateResponse sessionCreate(String authorization, SessionCreateRequest sessionCreateRequest) {\r\n        log.trace(\"SessionServiceImpl.sessionCreate - authorization {}, sessionCreateRequest {}\", authorization, sessionCreateRequest);\r\n\r\n        /**  Проверка на организацию пользователя*/\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = organizationService.getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        /** Проврека мероприятия на существование */\r\n        Event event = eventService.getEventById(sessionCreateRequest.eventId());\r\n\r\n        if (event == null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Event error\", \"The event does not exist!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Проврека зала на существование */\r\n        Hall hall = hallService.getHallById(sessionCreateRequest.hallId());\r\n\r\n        if (hall == null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Hall error\", \"The hall does not exist!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Проврека времени */\r\n        LocalDateTime start = sessionCreateRequest.startTime();\r\n        LocalDateTime finish = start.plusHours(Long.parseLong(event.getDuration().split(\":\")[0]))\r\n                .plusMinutes(Long.parseLong(event.getDuration().split(\":\")[1]));\r\n\r\n        if (LocalDateTime.now().isAfter(start)) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Start time error\", \"The date and time of the start of the event must be in the future!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Получения типа сеанса */\r\n        TypeOfMovie typeOfMovie = typeOfMovieService.getTypeByName(sessionCreateRequest.typeOfMovie());\r\n\r\n        /** Проврерка на существование сеанса */\r\n        Session[] sessions = sessionRepository.findSessionsByInfo(Timestamp.valueOf(sessionCreateRequest.startTime()), Timestamp.valueOf(finish), hall.getId());\r\n\r\n        if (sessions.length != 0) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Session error\", \"It is impossible to create a session, because the hall does not exist, or it is occupied!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Сохранение сеанса */\r\n        Session session = new Session(\r\n                0,\r\n                hall.getNumberOfSeats(),\r\n                Timestamp.valueOf(start),\r\n                Timestamp.valueOf(finish),\r\n                0,\r\n                sessionCreateRequest.price(),\r\n                true,\r\n                event,\r\n                hall,\r\n                typeOfMovie\r\n        );\r\n\r\n        sessionRepository.saveAndFlush(session);\r\n\r\n        return new MessageCreateResponse(\r\n                \"The session '\" + event.getEventBasicInformation().getName() +\"' in the hall '\" + hall.getHallName() + \"' has been successfully created!\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public Set<Event> getMassiveEventByCityLimit(City city, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityLimit - city {}, offset {}\", city, offset);\r\n        return sessionRepository.findAllEventByCity(city, offset, new Timestamp(date.getTime()));\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам и дате создания мероприятия\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public Set<Event> getMassiveAnnouncementByCityLimit(City city, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveAnnouncementByCityLimit - city {}, offset {}\", city, offset);\r\n        return sessionRepository.findAllEventAdvertisementByCity(city, offset, new Timestamp(date.getTime()), new Timestamp(date.getTime() - 1000000000));\r\n    }\r\n\r\n    /**\r\n     * Метод получения сеансов мероприятия по городу и дате\r\n     * @param event мероприятие\r\n     * @param city город\r\n     * @param date дата для поиска\r\n     * @return массив сеансов\r\n     */\r\n    @Override\r\n    public ArrayList<Session> getSessionsByEvent(Event event, City city, Date date) {\r\n        log.trace(\"SessionServiceImpl.getSessionsByEvent - event {}, city {}, date {}\", event, city, date);\r\n        return sessionRepository.findAllSessionByEventAndCity(\r\n                event,\r\n                city,\r\n                Timestamp.valueOf(date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate().atStartOfDay()),\r\n                Timestamp.valueOf(date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate().atTime(LocalTime.MAX)));\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по возрасту\r\n     * @param city город\r\n     * @param age возраст\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n     @Override\r\n    public Set<Event> getMassiveEventByCityAndAgeLimit(City city, int age, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityLimit - city {}, age {}, offset {}\", city, age, offset);\r\n        return sessionRepository.findAllEventByCityAndAge(city, age, offset, new Timestamp(date.getTime()));\r\n    }\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по возрасту\r\n     * @param city город\r\n     * @param type тип мероприятия\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    @Override\r\n    public Set<Event> getMassiveEventByCityAndType(City city, String type, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityLimit - city {}, type {}, offset {}\", city, type, offset);\r\n        return sessionRepository.findAllEventByCityAndType(city, type, offset, new Timestamp(date.getTime()));\r\n    }\r\n\r\n    /*\r\n    @Override\r\n    public Set<Event> getMassiveEventByCityAndGenre(City city, Genre genre, Integer offset, Date date) {\r\n        log.trace(\"SessionServiceImpl.getMassiveEventByCityLimit - city {}, genre {}, offset {}\", city, genre, offset);\r\n        return sessionRepository.findAllEventByCityAndGenre(city, genre, offset, new Timestamp(date.getTime()));\r\n    }\r\n     */\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java b/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/service/Impl/SessionServiceImpl.java	(date 1715960748477)
@@ -197,11 +197,11 @@
         return sessionRepository.findAllEventByCityAndType(city, type, offset, new Timestamp(date.getTime()));
     }
 
-    /*
+
     @Override
     public Set<Event> getMassiveEventByCityAndGenre(City city, Genre genre, Integer offset, Date date) {
         log.trace("SessionServiceImpl.getMassiveEventByCityLimit - city {}, genre {}, offset {}", city, genre, offset);
         return sessionRepository.findAllEventByCityAndGenre(city, genre, offset, new Timestamp(date.getTime()));
     }
-     */
+
 }
Index: src/main/java/biletka/main/service/EventService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.dto.request.EventCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.universal.MassivePublicEvent;\r\nimport biletka.main.dto.universal.PublicEventImage;\r\nimport biletka.main.dto.universal.PublicFullInfoEvent;\r\nimport biletka.main.entity.Event;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.IOException;\r\nimport java.util.Date;\r\n\r\n@Service\r\npublic interface EventService {\r\n    /**\r\n     * Метод создания и добавления мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param file изображение мероприятия\r\n     * @param eventCreateRequest информация мероприятия\r\n     * @return сообщение оуспешном создании мероприятия\r\n     */\r\n    MessageCreateResponse createEvent(String authorization, MultipartFile file, EventCreateRequest eventCreateRequest) throws IOException;\r\n\r\n    /**\r\n     * Метод получения мероприятия по id\r\n     * @param id мероприятия\r\n     * @return мероприятие\r\n     */\r\n    Event getEventById(Long id);\r\n\r\n    /**\r\n     * Метод получения изображения мероприятия\r\n     * @param id мероприятия\r\n     * @param symbolicName символичное название мероприятия\r\n     * @return данные для изображения\r\n     */\r\n    PublicEventImage getImageEvent(String id, String symbolicName) throws IOException;\r\n\r\n    /**\r\n     * Метод получения кртакой информации о 10 мероприятиях по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getEventLimit(String cityName, String authorization, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения анонсов 10 мероприятий по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getAnnouncementLimit(String cityName, String authorization, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения полной информации меропрития и места проведения и его сеансов\r\n     * @param authorization токе авторизации\r\n     * @param cityName название города\r\n     * @param eventName id и символьное название мероприятия\r\n     * @param date дата для поиска\r\n     * @return полная информация мероприятия\r\n     */\r\n    PublicFullInfoEvent getFullInfoEvent(String authorization, String cityName, String eventName, Date date);\r\n\r\n    /**\r\n     * Метод получения кртакой информации о мероприятиях подходящих под указанный возраст\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    MassivePublicEvent getEventsByCityAndAgeLimit(String cityName, int age, String authorization, Integer offset, Date date);\r\n\r\n    MassivePublicEvent getEventsByCityAndType(String cityName, String type, String authorization, Integer offset, Date date);\r\n\r\n    //MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/EventService.java b/src/main/java/biletka/main/service/EventService.java
--- a/src/main/java/biletka/main/service/EventService.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/service/EventService.java	(date 1715960313873)
@@ -79,5 +79,5 @@
 
     MassivePublicEvent getEventsByCityAndType(String cityName, String type, String authorization, Integer offset, Date date);
 
-    //MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date);
+    MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date);
 }
Index: src/main/java/biletka/main/service/SessionService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service;\r\n\r\nimport biletka.main.dto.request.SessionCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.entity.AgeRating;\r\nimport biletka.main.entity.City;\r\nimport biletka.main.entity.Event;\r\nimport biletka.main.entity.Session;\r\nimport biletka.main.entity.Genre;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.Set;\r\n\r\n@Service\r\npublic interface SessionService {\r\n    /**\r\n     * Метод создания и сохранения сеанса мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param sessionCreateRequest информация о сеансе\r\n     * @return о успешном создании сеанса\r\n     */\r\n    MessageCreateResponse sessionCreate(String authorization, SessionCreateRequest sessionCreateRequest);\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveEventByCityLimit(City city, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по сеансам и дате создания мероприятия\r\n     * @param city город\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveAnnouncementByCityLimit(City city, Integer offset, Date date);\r\n\r\n    /**\r\n     * Метод получения сеансов мероприятия по городу и дате\r\n     * @param event мероприятие\r\n     * @param city город\r\n     * @param date дата для поиска\r\n     * @return массив сеансов\r\n     */\r\n    ArrayList<Session> getSessionsByEvent(Event event, City city, Date date);\r\n\r\n    /**\r\n     * Метод получения уникальных мероприятий по возрасту\r\n     * @param city город\r\n     * @param age возраст\r\n     * @param offset отступ\r\n     * @param date дата для выборки\r\n     * @return массив мероприятий\r\n     */\r\n    Set<Event> getMassiveEventByCityAndAgeLimit(City city, int age, Integer offset, Date date);\r\n\r\n    Set<Event> getMassiveEventByCityAndType(City city, String type, Integer offset, Date date);\r\n\r\n    //Set<Event> getMassiveEventByCityAndGenre(City city, Genre genre, Integer offset, Date date);\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/SessionService.java b/src/main/java/biletka/main/service/SessionService.java
--- a/src/main/java/biletka/main/service/SessionService.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/service/SessionService.java	(date 1715960748487)
@@ -62,5 +62,5 @@
 
     Set<Event> getMassiveEventByCityAndType(City city, String type, Integer offset, Date date);
 
-    //Set<Event> getMassiveEventByCityAndGenre(City city, Genre genre, Integer offset, Date date);
+    Set<Event> getMassiveEventByCityAndGenre(City city, Genre genre, Integer offset, Date date);
 }
Index: src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.OrganizationRegistrationRequest;\r\nimport biletka.main.dto.response.OrganizationResponse;\r\nimport biletka.main.entity.Event;\r\nimport biletka.main.entity.Organization;\r\nimport biletka.main.entity.Place;\r\nimport biletka.main.entity.Users;\r\nimport biletka.main.enums.StatusUserEnum;\r\nimport biletka.main.repository.OrganizationRepository;\r\nimport biletka.main.service.OrganizationService;\r\nimport biletka.main.service.UserService;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\n// не ту библиотеку инициализировал. Нужна была не ломбока\r\n\r\nimport java.sql.Timestamp;\r\nimport java.util.Date;\r\nimport java.util.Set;\r\n\r\n@Service\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\n@Slf4j\r\npublic class OrganizationServiceImpl implements OrganizationService {\r\n    private final OrganizationRepository organizationRepository;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n\r\n    @Lazy\r\n    private final UserService userService;\r\n\r\n\r\n    /**\r\n     * Метод добавления организации в бд\r\n     * @param organizationRequest данные организации\r\n     * @param user данные о новом пользователе\r\n     */\r\n    @Override\r\n    public void postCreateOrganization(OrganizationRegistrationRequest organizationRequest, Users user) {\r\n        log.trace(\"OrganizationServiceImpl.postCreateOrganization - organizationRequest {}, user {}\", organizationRequest, user);\r\n        Organization organization = new Organization(\r\n                user,\r\n                organizationRequest.inn(),\r\n                organizationRequest.kbk(),\r\n                organizationRequest.kpp(),\r\n                organizationRequest.ogrn(),\r\n                organizationRequest.oktmo(),\r\n                organizationRequest.contactPhone(),\r\n                organizationRequest.email(),\r\n                organizationRequest.fullNameOrganization(),\r\n                organizationRequest.fullNameSignatory(),\r\n                organizationRequest.legalAddress(),\r\n                organizationRequest.namePayer(),\r\n                organizationRequest.positionSignatory(),\r\n                Integer.valueOf(organizationRequest.postalAddress()),\r\n                new Timestamp(new Date().getTime()),\r\n                StatusUserEnum.ACTIVE,\r\n                null\r\n        );\r\n\r\n        organizationRepository.saveAndFlush(organization);\r\n    }\r\n\r\n    /**\r\n     * Метод получения организации по данным\r\n     * @param organizationRequest данные организации\r\n     * @return организация\r\n     */\r\n    @Override\r\n    public Organization getOrganizationByFullNameOrganization(OrganizationRegistrationRequest organizationRequest) {\r\n        log.trace(\"OrganizationServiceImpl.getOrganizationByFullNameOrganization - organizationRequest {}\", organizationRequest);\r\n        return organizationRepository.findFirstByFullInfo(\r\n                organizationRequest.inn(),\r\n                organizationRequest.kbk(),\r\n                organizationRequest.kpp(),\r\n                organizationRequest.ogrn(),\r\n                organizationRequest.oktmo(),\r\n                organizationRequest.email(),\r\n                organizationRequest.fullNameOrganization()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения организации по пользователю\r\n     * @param user пользователь\r\n     * @return организация\r\n     */\r\n    @Override\r\n    public Organization getOrganizationByUser(Users user) {\r\n        log.trace(\"OrganizationServiceImpl.getOrganizationByUser - user {}\", user);\r\n        return organizationRepository.findFirstByUser(user);\r\n    }\r\n\r\n    /**\r\n     * Метод добавление площадки к организации\r\n     * @param newPlace площадка\r\n     */\r\n    @Override\r\n    public void addPlace(Organization organization, Place newPlace) {\r\n        log.trace(\"OrganizationServiceImpl.addPlace - organization {}, newPlace {}\", organization, newPlace);\r\n        organization.addPlace(newPlace);\r\n\r\n        organizationRepository.save(organization);\r\n    }\r\n\r\n    /**\r\n     * Метод добавление мероприятия к организации\r\n     * @param event мероприятие\r\n     */\r\n    @Override\r\n    public void addEventAdmin(Organization organization, Event event) {\r\n        log.trace(\"OrganizationServiceImpl.addEventAdmin - organization {}, event {}\", organization, event);\r\n        Set<Event> eventSet = organization.getAdminEventSet();\r\n        eventSet.add(event);\r\n\r\n        organization.addEvent(event);\r\n        organization.setAdminEventSet(eventSet);\r\n\r\n        organizationRepository.save(organization);\r\n    }\r\n\r\n    /**\r\n     * Метод получения организации по токену\r\n     * @param authorization - токен авторизации\r\n     * @return организация\r\n     */\r\n    @Override\r\n    public OrganizationResponse getOrganization(String authorization){\r\n        log.trace(\"OrganizationServiceImpl.getAllOrganization - authorization {}\", authorization);\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n        return new OrganizationResponse(\r\n                organization.getId(),\r\n                organization.getUser(),\r\n                organization.getInn(),\r\n                organization.getKbk(),\r\n                organization.getKpp(),\r\n                organization.getOgrn(),\r\n                organization.getOktmo(),\r\n                organization.getContactPhone(),\r\n                organization.getEmail(),\r\n                organization.getFullNameOrganization(),\r\n                organization.getFullNameSignatory(),\r\n                organization.getLegalAddress(),\r\n                organization.getNamePayer(),\r\n                organization.getPositionSignatory(),\r\n                organization.getPostalAddress()\r\n        );\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java b/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/service/Impl/OrganizationServiceImpl.java	(date 1716135651027)
@@ -3,6 +3,9 @@
 import biletka.main.Utils.JwtTokenUtils;
 import biletka.main.dto.request.OrganizationRegistrationRequest;
 import biletka.main.dto.response.OrganizationResponse;
+import biletka.main.dto.response.TotalSession;
+import biletka.main.dto.universal.MassivePublicEvent;
+import biletka.main.dto.universal.PublicEvent;
 import biletka.main.entity.Event;
 import biletka.main.entity.Organization;
 import biletka.main.entity.Place;
@@ -19,7 +22,9 @@
 // не ту библиотеку инициализировал. Нужна была не ломбока
 
 import java.sql.Timestamp;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Set;
 
 @Service
@@ -163,4 +168,33 @@
                 organization.getPostalAddress()
         );
     }
+
+    public MassiveTotalSession getSessionSumByPlace(String authorization){
+        log.trace("OrganizationServiceImpl.getAllOrganization - authorization {}", authorization);
+        String userEmail = jwtTokenUtils.getUsernameFromToken(
+                authorization.substring(7)
+        );
+
+        Users user = userService.getUserOrganizationByEmail(userEmail);
+
+        if (user == null) {
+            throw new EntityNotFoundException("A broken token!");
+        }
+
+        Organization organization = getOrganizationByUser(user);
+
+        if (organization == null) {
+            throw new EntityNotFoundException("A broken token!");
+        }
+        Set<Place> places = organization.getPlaceSet();
+        places.forEach(place -> );
+        ArrayList<TotalSession> totalSessions= new ArrayList<>();
+
+        totalSessions.add(
+                new TotalSession(
+
+                )
+        );
+        return new MassiveTotalSession(totalSessions.toArray(TotalSession[]::new));
+    }
 }
Index: src/main/java/biletka/main/service/Impl/EventServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.FileUtils;\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.EventCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.universal.*;\r\nimport biletka.main.entity.*;\r\nimport biletka.main.entity.event_item.EventAdditionalInformation;\r\nimport biletka.main.entity.event_item.EventBasicInformation;\r\nimport biletka.main.entity.event_item.EventWebWidget;\r\nimport biletka.main.enums.StatusEventEnum;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.EventRepository;\r\nimport biletka.main.service.*;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.IOException;\r\nimport java.sql.Timestamp;\r\nimport java.time.LocalDateTime;\r\nimport java.util.*;\r\nimport java.util.regex.Pattern;\r\n\r\n@Service\r\n@RequiredArgsConstructor(onConstructor = @__(@Lazy))\r\n@Slf4j\r\npublic class EventServiceImpl implements EventService {\r\n    private final FileUtils fileUtils;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final EventRepository eventRepository;\r\n\r\n    private final EventBasicInformationService eventBasicInformationService;\r\n    private final EventAdditionalInformationService eventAdditionalInformationService;\r\n    private final EventWebWidgetService eventWebWidgetService;\r\n    private final UserService userService;\r\n    private final OrganizationService organizationService;\r\n    private final CityService cityService;\r\n    private final ClientService clientService;\r\n    private final GenreService genreService;\r\n    @Lazy\r\n    private final SessionService sessionService;\r\n\r\n    /**\r\n     * Метод создания и добавления мероприятия в бд\r\n     * @param authorization токен авторизации\r\n     * @param file изображение мероприятия\r\n     * @param eventCreateRequest информация мероприятия\r\n     * @return сообщение оуспешном создании мероприятия\r\n     */\r\n    @Override\r\n    public MessageCreateResponse createEvent(String authorization, MultipartFile file, EventCreateRequest eventCreateRequest) throws IOException {\r\n        log.trace(\"EventServiceImpl.createEvent - authorization {}, file {}, eventCreateRequest {}\", authorization, file.getOriginalFilename(), eventCreateRequest);\r\n        /** Проверка на типа файла */\r\n        String typeFile = fileUtils.getFileExtension(file.getOriginalFilename());\r\n        ArrayList<String> pattern = new ArrayList<>();\r\n        pattern.add(\"png\");\r\n        pattern.add(\"jpg\");\r\n\r\n        fileUtils.validationFile(\r\n                typeFile,\r\n                pattern\r\n        );\r\n\r\n        /**  Проверка на организацию пользователя*/\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = organizationService.getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        /** Проверка на существование мероприятия */\r\n        Event event = eventRepository.findFirstByName(eventCreateRequest.eventBasicRequest().name(), eventCreateRequest.eventBasicRequest().typeEvent());\r\n\r\n        if (event != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Create event error\", \"This event already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        /** Создание дочерних элементов */\r\n        EventBasicInformation eventBasicInformation = eventBasicInformationService.createEventBasic(eventCreateRequest.eventBasicRequest(), file.getOriginalFilename());\r\n        EventAdditionalInformation eventAdditionalInformation = eventAdditionalInformationService.createEventAdditional(eventCreateRequest.eventAdditional());\r\n        EventWebWidget eventWebWidget = eventWebWidgetService.createEventWebWidget(eventCreateRequest.webWidget());\r\n\r\n        Event eventNew = new Event(\r\n                eventWebWidget,\r\n                eventAdditionalInformation,\r\n                eventBasicInformation,\r\n                eventCreateRequest.duration(),\r\n                0.0,\r\n                new Timestamp(new Date().getTime()),\r\n                StatusEventEnum.ACTIVE\r\n        );\r\n\r\n        eventRepository.saveAndFlush(eventNew);\r\n\r\n        /** Добавление мероприятия к организации */\r\n        organizationService.addEventAdmin(organization, eventNew);\r\n\r\n        /** Сохранение файла */\r\n        fileUtils.fileUpload(file, \"event/\" + eventNew.getId() + \"-\" + eventNew.getEventBasicInformation().getSymbolicName() + \".\" + typeFile);\r\n\r\n        return new MessageCreateResponse(\r\n                \"The event '\" + eventNew.getEventBasicInformation().getName() + \"' of the '\" + eventNew.getEventBasicInformation().getTypeEventId().getType() + \"' type has been successfully created!\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения мероприятия по id\r\n     * @param id мероприятия\r\n     * @return мероприятие\r\n     */\r\n    @Override\r\n    public Event getEventById(Long id) {\r\n        log.trace(\"EventServiceImpl.getEventById - id {}\", id);\r\n        return eventRepository.getReferenceById(id);\r\n    }\r\n\r\n    /**\r\n     * Метод получения изображения мероприятия\r\n     * @param id мероприятия\r\n     * @param symbolicName символичное название мероприятия\r\n     * @return данные для изображения\r\n     */\r\n    @Override\r\n    public PublicEventImage getImageEvent(String id, String symbolicName) throws EntityNotFoundException, IOException {\r\n        log.trace(\"EventServiceImpl.getImageEvent - id {}, symbolicName {}\", id, symbolicName);\r\n        Event event = eventRepository.findFirstByIdAndSymbolicName(Long.valueOf(id), symbolicName);\r\n\r\n        if (event == null) {\r\n            throw new EntityNotFoundException(\"The event not found!\");\r\n        }\r\n\r\n        return fileUtils.getFileEvent(event.getEventBasicInformation().getImg());\r\n    }\r\n\r\n    /**\r\n     * Метод получения кртакой информации о 10 мероприятиях по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getEventLimit(String cityName, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, offset {}, date {}\", cityName, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя*/\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n\r\n            favoriteSet.addAll(client.getEventSet());\r\n        }\r\n\r\n        Set<Event> events = sessionService.getMassiveEventByCityLimit(city, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /**\r\n     * Метод получения анонсов 10 мероприятий по городу\r\n     * @param cityName название города\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getAnnouncementLimit(String cityName, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.getAnnouncementLimit - cityName {}, offset {}, date {}\", cityName, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents = new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя*/\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n\r\n            favoriteSet.addAll(client.getEventSet());\r\n        }\r\n\r\n        Set<Event> events = sessionService.getMassiveAnnouncementByCityLimit(city, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /**\r\n     * Метод получения полной информации меропрития и места проведения и его сеансов\r\n     * @param authorization токе авторизации\r\n     * @param cityName название города\r\n     * @param eventName id и символьное название мероприятия\r\n     * @param date дата для поиска\r\n     * @return полная информация мероприятия\r\n     */\r\n    @Override\r\n    public PublicFullInfoEvent getFullInfoEvent(String authorization, String cityName, String eventName, Date date) throws EntityNotFoundException {\r\n        log.trace(\"EventServiceImpl.getFullInfoEvent - cityName {}, event {}, date {}\", cityName, eventName, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n\r\n        /**  Проверка на пользователя*/\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n\r\n            favoriteSet.addAll(client.getEventSet());\r\n        }\r\n\r\n        String[] eventStringName = eventName.split(\"-\", 2);\r\n\r\n        if (!Pattern.compile(\"^\\\\d+$\").matcher(eventStringName[0]).matches() &&\r\n                !Pattern.compile(\"^[A-Za-z0-9._%+@-]+$\").matcher(eventStringName[1]).matches()\r\n        ) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Event error\", \"The event line was entered incorrectly!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        Event event = eventRepository.findFirstByIdAndSymbolicName(Long.valueOf(eventStringName[0]), eventStringName[1]);\r\n\r\n        if (event == null) {\r\n            throw new EntityNotFoundException(\"There is no such event!\");\r\n        }\r\n\r\n        ArrayList<MassiveSessionEvent> massiveSessionEvents = new ArrayList<>();\r\n\r\n        ArrayList<Session> sessions = sessionService.getSessionsByEvent(event, city, date);\r\n\r\n        if (!sessions.isEmpty()) {\r\n            ArrayList<Place> places = new ArrayList<>();\r\n            ArrayList<PublicSession> publicSessions = new ArrayList<>();\r\n\r\n            Session lastSession = sessions.get(sessions.size() - 1);\r\n\r\n            sessions.forEach(session -> {\r\n                PublicSession publicSession = new PublicSession(\r\n                        session.getId(),\r\n                        session.getPrice(),\r\n                        session.getStartTime().toLocalDateTime(),\r\n                        (session.getOnSales() != 0) && (!LocalDateTime.now().isAfter(session.getStartTime().toLocalDateTime()))\r\n                );\r\n\r\n                if (lastSession == session) {\r\n                    publicSessions.add(\r\n                            publicSession\r\n                    );\r\n\r\n                    massiveSessionEvents.add(\r\n                            new MassiveSessionEvent(\r\n                                    session.getHall().getPlace().getPlaceName(),\r\n                                    session.getHall().getPlace().getAddress(),\r\n                                    publicSessions.toArray(PublicSession[]::new)\r\n                            )\r\n                    );\r\n                } else if (!places.contains(session.getHall().getPlace())) {\r\n                    if (!publicSessions.isEmpty()) {\r\n                        massiveSessionEvents.add(\r\n                                new MassiveSessionEvent(\r\n                                        places.get(places.size() - 1).getPlaceName(),\r\n                                        places.get(places.size() - 1).getAddress(),\r\n                                        publicSessions.toArray(PublicSession[]::new)\r\n                                )\r\n                        );\r\n\r\n                        publicSessions.clear();\r\n                    }\r\n\r\n                    places.add(session.getHall().getPlace());\r\n                }\r\n\r\n                publicSessions.add(publicSession);\r\n            });\r\n        }\r\n\r\n        ArrayList<String> genres = new ArrayList<>();\r\n        ArrayList<String> actors = new ArrayList<>();\r\n        ArrayList<String> tags = new ArrayList<>();\r\n\r\n        event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n        event.getEventAdditionalInformation().getActorSet().forEach(actor -> actors.add(actor.getName()));\r\n        event.getEventAdditionalInformation().getTagSet().forEach(tag -> tags.add(tag.getName()));\r\n\r\n        PublicFullInfoEvent publicSession = new PublicFullInfoEvent(\r\n                event.getId(),\r\n                event.getEventBasicInformation().getName_rus(),\r\n                event.getEventBasicInformation().getSymbolicName(),\r\n                event.getEventWebWidget().getDescription(),\r\n                event.getDuration(),\r\n                event.getRating(),\r\n                event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                genres.toArray(String[]::new),\r\n                event.getEventBasicInformation().getPushkin(),\r\n                event.getEventBasicInformation().getImg(),\r\n                event.getEventBasicInformation().getTypeEventId().getType(),\r\n                event.getEventAdditionalInformation().getWriterOrArtist(),\r\n                actors.toArray(String[]::new),\r\n                tags.toArray(String[]::new),\r\n                authorization == null ? null : favoriteSet.contains(event),\r\n                massiveSessionEvents.toArray(MassiveSessionEvent[]::new)\r\n        );\r\n\r\n        return publicSession;\r\n    }\r\n\r\n    /**\r\n     * Метод получения кртакой информации о мероприятиях подходящих под указанный возраст\r\n     * @param cityName название города\r\n     * @param age возраст клиента\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getEventsByCityAndAgeLimit(String cityName, int age, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, age {}, offset {}, date {}\", cityName, age, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя */\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n            favoriteSet.addAll(client.getEventSet());\r\n\r\n        }\r\n\r\n        Set<Event> events = sessionService.getMassiveEventByCityAndAgeLimit(city, age, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /**\r\n     * Метод получения кртакой информации о мероприятиях подходящих под указанный тип\r\n     * @param cityName название города\r\n     * @param type тип мероприятия\r\n     * @param authorization токен авторизации\r\n     * @param offset отсчет мероприятий\r\n     * @param date дата для выборки\r\n     * @return массив краткой информации\r\n     */\r\n    @Override\r\n    public MassivePublicEvent getEventsByCityAndType(String cityName, String type, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, type {}, offset {}, date {}\", cityName, type, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n\r\n        /**  Проверка на пользователя */\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n            favoriteSet.addAll(client.getEventSet());\r\n\r\n        }\r\n\r\n        Set<Event> events = sessionService.getMassiveEventByCityAndType(city, type, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n\r\n    /*\r\n    @Override\r\n    public MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date) {\r\n        log.trace(\"EventServiceImpl.cityName - cityName {}, genre {}, offset {}, date {}\", cityName, Genre, offset, date);\r\n        City city = cityService.getCityByNameEng(cityName);\r\n\r\n        Set<Event> favoriteSet = new HashSet<>();\r\n        ArrayList<PublicEvent> publicEvents= new ArrayList<>();\r\n\r\n       //  Проверка на пользователя\r\n        if (authorization != null) {\r\n            String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                    authorization.substring(7)\r\n            );\r\n            Users user = userService.getUserByEmail(userEmail);\r\n\r\n            if (user == null) {\r\n                throw new EntityNotFoundException(\"A broken token!\");\r\n            }\r\n\r\n            Client client = clientService.getClientByUser(user);\r\n            favoriteSet.addAll(client.getEventSet());\r\n\r\n        }\r\n\r\n        Genre g = genreService.getGenreOfName(Genre);\r\n        Set<Event> events = sessionService.getMassiveEventByCityAndGenre(city, g, offset, date);\r\n\r\n        events.forEach(event -> {\r\n            Set<String> genres = new HashSet<>();\r\n\r\n            event.getEventBasicInformation().getGenres().forEach(genre -> genres.add(genre.getName()));\r\n\r\n            publicEvents.add(\r\n                    new PublicEvent(\r\n                            event.getId(),\r\n                            event.getEventBasicInformation().getName_rus(),\r\n                            event.getEventBasicInformation().getSymbolicName(),\r\n                            event.getEventBasicInformation().getAgeRatingId().getLimitation(),\r\n                            genres.toArray(String[]::new),\r\n                            event.getEventBasicInformation().getImg(),\r\n                            event.getEventBasicInformation().getTypeEventId().getType(),\r\n                            authorization == null ? null : favoriteSet.contains(event)\r\n                    )\r\n            );\r\n        });\r\n\r\n        return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));\r\n    }\r\n    */\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/EventServiceImpl.java b/src/main/java/biletka/main/service/Impl/EventServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/EventServiceImpl.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/service/Impl/EventServiceImpl.java	(date 1715960748465)
@@ -505,7 +505,7 @@
         return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));
     }
 
-    /*
+
     @Override
     public MassivePublicEvent getEventsByCityAndGenre(String cityName, String Genre, String authorization, Integer offset, Date date) {
         log.trace("EventServiceImpl.cityName - cityName {}, genre {}, offset {}, date {}", cityName, Genre, offset, date);
@@ -554,5 +554,5 @@
 
         return new MassivePublicEvent(publicEvents.toArray(PublicEvent[]::new));
     }
-    */
+
 }
Index: src/main/java/biletka/main/repository/SessionRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.repository;\r\n\r\nimport biletka.main.entity.*;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\n\r\nimport java.sql.Timestamp;\r\nimport java.util.ArrayList;\r\nimport java.util.Set;\r\n\r\npublic interface SessionRepository extends JpaRepository<Session, Long> {\r\n\r\n    @Query(value = \"SELECT * FROM session \" +\r\n            \"WHERE session.hall_id = :id \" +\r\n            \"AND (session.start_time BETWEEN :start AND :finish \" +\r\n            \"OR session.finish_time BETWEEN :start AND :finish) \", nativeQuery = true)\r\n    Session[] findSessionsByInfo(Timestamp start, Timestamp finish, Long id);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCity(City city, Integer offset, Timestamp nowDate);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"AND s.event.createdAt >= :createDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventAdvertisementByCity(City city, Integer offset, Timestamp nowDate, Timestamp createDate);\r\n\r\n    @Query(\"SELECT s FROM Session s \" +\r\n            \"WHERE s.event = :event \" +\r\n            \"AND s.hall.place.city = :city \" +\r\n            \"AND s.startTime BETWEEN :startDay AND :finishDay \" +\r\n            \"ORDER BY s.hall.place, s.startTime \")\r\n    ArrayList<Session> findAllSessionByEventAndCity(Event event, City city, Timestamp startDay, Timestamp finishDay);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.event.eventBasicInformation.ageRatingId.limitation <= :age \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCityAndAge (City city, int age, Integer offset, Timestamp nowDate);\r\n\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND s.event.eventBasicInformation.typeEventId.type = :type \" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCityAndType (City city, String type, Integer offset, Timestamp nowDate);\r\n\r\n/*\r\n    @Query(\"SELECT s.event FROM Session s \" +\r\n            \"WHERE s.hall.place.city = :city \" +\r\n            \"AND :genre = ANY(s.event.eventBasicInformation.genres)\" +\r\n            \"AND s.startTime >= :nowDate \" +\r\n            \"ORDER BY s.id \" +\r\n            \"LIMIT 10 OFFSET :offset\")\r\n    Set<Event> findAllEventByCityAndGenre (City city, Genre genre, Integer offset, Timestamp nowDate);\r\n*/\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/repository/SessionRepository.java b/src/main/java/biletka/main/repository/SessionRepository.java
--- a/src/main/java/biletka/main/repository/SessionRepository.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/repository/SessionRepository.java	(date 1716135651016)
@@ -54,14 +54,17 @@
             "LIMIT 10 OFFSET :offset")
     Set<Event> findAllEventByCityAndType (City city, String type, Integer offset, Timestamp nowDate);
 
-/*
+
     @Query("SELECT s.event FROM Session s " +
             "WHERE s.hall.place.city = :city " +
-            "AND :genre = ANY(s.event.eventBasicInformation.genres)" +
+            "AND EXISTS (SELECT g FROM s.event.eventBasicInformation.genres g WHERE g = :genre) " +
             "AND s.startTime >= :nowDate " +
             "ORDER BY s.id " +
             "LIMIT 10 OFFSET :offset")
     Set<Event> findAllEventByCityAndGenre (City city, Genre genre, Integer offset, Timestamp nowDate);
-*/
+
+    @Query("SELECT s FROM Session s "+
+    "WHERE s.hall.place = :place")
+    Set<Session> findAllSessionByPlace (Place place);
 }
 
Index: src/main/java/biletka/main/controller/EventController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.controller;\r\n\r\nimport biletka.main.Utils.ConvertUtils;\r\nimport biletka.main.dto.request.EventCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.dto.universal.MassivePublicEvent;\r\nimport biletka.main.dto.universal.PublicEventImage;\r\nimport biletka.main.dto.universal.PublicFullInfoEvent;\r\nimport biletka.main.service.EventService;\r\nimport io.swagger.v3.oas.annotations.Operation;\r\nimport io.swagger.v3.oas.annotations.Parameter;\r\nimport io.swagger.v3.oas.annotations.tags.Tag;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.format.annotation.DateTimeFormat;\r\nimport org.springframework.http.HttpRequest;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.IOException;\r\nimport java.net.http.HttpResponse;\r\nimport java.sql.Timestamp;\r\nimport java.util.Date;\r\n\r\n@Slf4j\r\n@RestController\r\n@RequestMapping(\"/event\")\r\n@RequiredArgsConstructor\r\n@Tag(name = \"Контроллер ивентов\", description = \"Всё, что связано с ивентами\")\r\n@CrossOrigin\r\npublic class EventController {\r\n    private final EventService eventService;\r\n\r\n    private final ConvertUtils convertToJSON;\r\n\r\n    @Operation(\r\n            summary = \"Создание мероприятия\",\r\n            description = \"Позволяет создать мероприятие\"\r\n    )\r\n    @PostMapping\r\n    public ResponseEntity<MessageCreateResponse> postEventCreate(@Parameter(description = \"токен пользователя\") @RequestHeader(\"Authorization\") String authorization,\r\n                                             @RequestPart(\"file\") MultipartFile file,\r\n                                             @RequestPart(\"event_create_request\") String eventCreateRequest) throws IOException {\r\n        log.trace(\"EventController.postEventCreate / - file {}, eventCreateRequest {}\", file, eventCreateRequest);\r\n        EventCreateRequest eventCreateRequestNew = convertToJSON.convertToJSONEventCreate(eventCreateRequest);\r\n        MessageCreateResponse message = eventService.createEvent(authorization, file, eventCreateRequestNew);\r\n\r\n        return ResponseEntity.status(HttpStatus.CREATED).body(message);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод 10 мероприятий\",\r\n            description = \"Вывод 10 мероприятий по городу\"\r\n    )\r\n    @GetMapping(\"/{cityName}\")\r\n    public ResponseEntity<MassivePublicEvent> getEventLimit(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                            @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                            @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                            @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventLimit / - cityName {}, authorization {}, offset {}, date {}\", cityName, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventLimit(cityName, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод 10 анонсов\",\r\n            description = \"Вывод 10 мероприятий по городу и будущим сеансам, которых не было\"\r\n    )\r\n    @GetMapping(\"/{cityName}/announcement\")\r\n    public ResponseEntity<MassivePublicEvent> getAnnouncementLimit(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                  @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                  @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                  @Parameter(description = \"дата для выборки\") @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date date) {\r\n        log.trace(\"EventController.getAnnouncementLimit / - cityName {}, authorization {}, offset {}, date {}\", cityName, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getAnnouncementLimit(cityName, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод полной информации о мероприятии\",\r\n            description = \"Вывод полной информации о мероприятии по id и символьному названию\"\r\n    )\r\n    @GetMapping(\"/{cityName}/{eventName}\")\r\n    public ResponseEntity<?> getFillInfoEvent(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                              @Parameter(description = \"название мероприятия\") @PathVariable String eventName,\r\n                                              @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                              @Parameter(description = \"дата для выборки\") @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) Date date) {\r\n        log.trace(\"EventController.getAnnouncementLimit / - cityName {}, eventName {}, authorization {}, date {}\", cityName, eventName, authorization, date);\r\n        PublicFullInfoEvent publicFullInfoEvent = eventService.getFullInfoEvent(authorization, cityName, eventName, date);\r\n        return ResponseEntity.ok(publicFullInfoEvent);\r\n    }\r\n\r\n    @CrossOrigin\r\n    @Operation(\r\n            summary = \"Вывод изображения мероприятия\",\r\n            description = \"Вывод изображения мероприятия\"\r\n    )\r\n    @GetMapping(\"/img/{id}>>{symbolicName}\")\r\n    public void getImageEvent(@PathVariable String id,\r\n                              @PathVariable String symbolicName,\r\n                              HttpServletResponse response) throws IOException {\r\n        log.trace(\"EventController.getImageEvent  /img/{id}-{symbolicName} - id {}, symbolicName {}\", id, symbolicName);\r\n        PublicEventImage publicEventImage = eventService.getImageEvent(id, symbolicName);\r\n        response.setContentType(publicEventImage.type());\r\n        response.getOutputStream().write(publicEventImage.imageData());\r\n        response.getOutputStream().close();\r\n    }\r\n\r\n    @Operation(\r\n            summary = \"Вывод мероприятий по возрасту\",\r\n            description = \"Вывод мероприятий по указанному возрасту\"\r\n    )\r\n    @GetMapping(\"/{cityName}/age\")\r\n    public ResponseEntity<MassivePublicEvent> getEventByAge(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                            @Parameter(description = \"возраст\") @RequestParam int age,\r\n                                                            @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                            @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                            @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventByAge / - cityName {} / - age {}, authorization {}, offset {}, date {}\", cityName, age, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventsByCityAndAgeLimit(cityName, age, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n            @Operation(\r\n            summary = \"Вывод мероприятий по типу\",\r\n            description = \"Вывод мероприятий по указанному типу\"\r\n    )\r\n    @GetMapping(\"/{cityName}/type\")\r\n    public ResponseEntity<MassivePublicEvent> getEventByType(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                            @Parameter(description = \"тип\") @RequestParam String type,\r\n                                                            @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                            @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                            @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventByType / - cityName {} / - type {}, authorization {}, offset {}, date {}\", cityName, type, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventsByCityAndType(cityName, type, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n    /*\r\n    @Operation(\r\n            summary = \"Вывод мероприятий по жанрк\",\r\n            description = \"Вывод мероприятий по указанному женру\"\r\n    )\r\n    @GetMapping(\"/{cityName}/genre\")\r\n    public ResponseEntity<MassivePublicEvent> getEventByGenre(@Parameter(description = \"название города\") @PathVariable String cityName,\r\n                                                             @Parameter(description = \"жанр\") @RequestParam String genre,\r\n                                                             @Parameter(description = \"токен пользователя\") @RequestHeader(value = \"Authorization\", required = false) String authorization,\r\n                                                             @Parameter(description = \"отсчет мероприятий\") @RequestParam Integer offset,\r\n                                                             @Parameter(description = \"дата для выборки\") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {\r\n        log.trace(\"EventController.getEventByType / - cityName {} / - genre {}, authorization {}, offset {}, date {}\", cityName, genre, authorization, offset, date);\r\n        MassivePublicEvent massivePublicEvent = eventService.getEventsByCityAndGenre(cityName, genre, authorization, offset, date);\r\n        return ResponseEntity.ok(massivePublicEvent);\r\n    }\r\n\r\n     */\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/controller/EventController.java b/src/main/java/biletka/main/controller/EventController.java
--- a/src/main/java/biletka/main/controller/EventController.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/controller/EventController.java	(date 1715961907716)
@@ -140,9 +140,9 @@
         return ResponseEntity.ok(massivePublicEvent);
     }
 
-    /*
+
     @Operation(
-            summary = "Вывод мероприятий по жанрк",
+            summary = "Вывод мероприятий по жанру",
             description = "Вывод мероприятий по указанному женру"
     )
     @GetMapping("/{cityName}/genre")
@@ -151,11 +151,10 @@
                                                              @Parameter(description = "токен пользователя") @RequestHeader(value = "Authorization", required = false) String authorization,
                                                              @Parameter(description = "отсчет мероприятий") @RequestParam Integer offset,
                                                              @Parameter(description = "дата для выборки") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam Date date) {
-        log.trace("EventController.getEventByType / - cityName {} / - genre {}, authorization {}, offset {}, date {}", cityName, genre, authorization, offset, date);
+        log.trace("EventController.getEventByGenre / - cityName {} / - genre {}, authorization {}, offset {}, date {}", cityName, genre, authorization, offset, date);
         MassivePublicEvent massivePublicEvent = eventService.getEventsByCityAndGenre(cityName, genre, authorization, offset, date);
         return ResponseEntity.ok(massivePublicEvent);
     }
 
-     */
 
 }
Index: src/main/java/biletka/main/service/Impl/HallServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.service.Impl;\r\n\r\nimport biletka.main.Utils.FileUtils;\r\nimport biletka.main.Utils.JwtTokenUtils;\r\nimport biletka.main.dto.request.HallCreateRequest;\r\nimport biletka.main.dto.response.MessageCreateResponse;\r\nimport biletka.main.entity.Hall;\r\nimport biletka.main.entity.Organization;\r\nimport biletka.main.entity.Place;\r\nimport biletka.main.entity.Users;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport biletka.main.repository.HallRepository;\r\nimport biletka.main.service.*;\r\nimport jakarta.mail.MessagingException;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class HallServiceImpl implements HallService {\r\n    private final HallRepository hallRepository;\r\n    private final JwtTokenUtils jwtTokenUtils;\r\n    private final MailSender mailSender;\r\n    private final FileUtils fileUtils;\r\n\r\n    private final UserService userService;\r\n    private final OrganizationService organizationService;\r\n    private final PlaceService placeService;\r\n\r\n    /**\r\n     * Метод создания зала площадки без схемы (требуется подтверждение администратор)\r\n     * @param authorization токен авторизации\r\n     * @param file схема зала\r\n     * @param hallCreateRequestNew информация о зале\r\n     * @return сообщение о успешном создании зала\r\n     */\r\n    @Override\r\n    public MessageCreateResponse createHall(String authorization, MultipartFile file, HallCreateRequest hallCreateRequestNew) throws MessagingException, EntityNotFoundException {\r\n        log.trace(\"HallServiceImpl.createHall - authorization {}, file {}, hallCreateRequestNew {}\", authorization, file, hallCreateRequestNew);\r\n        String typeFile = fileUtils.getFileExtension(file.getOriginalFilename());\r\n\r\n        fileUtils.validationFile(\r\n                typeFile,\r\n                new String[]{\"svg\"}\r\n        );\r\n\r\n        String userEmail = jwtTokenUtils.getUsernameFromToken(\r\n                authorization.substring(7)\r\n        );\r\n\r\n        Users user = userService.getUserOrganizationByEmail(userEmail);\r\n\r\n        if (user == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Organization organization = organizationService.getOrganizationByUser(user);\r\n\r\n        if (organization == null) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Place place = placeService.getPlaceById(hallCreateRequestNew.placeId());\r\n\r\n        if (!organization.getPlaceSet().contains(place)) {\r\n            throw new EntityNotFoundException(\"A broken token!\");\r\n        }\r\n\r\n        Hall hall = hallRepository.findFirstByPlaceAndHallNumber(place, hallCreateRequestNew.hallNumber());\r\n\r\n        if (hall != null) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"Create hall error\", \"This hall already exists!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        hall = new Hall(\r\n                hallCreateRequestNew.hallNumber(),\r\n                hallCreateRequestNew.hallName(),\r\n                hallCreateRequestNew.numberOfSeats(),\r\n                hallCreateRequestNew.info(),\r\n                hallCreateRequestNew.seatGroupInfo(),\r\n                null,\r\n                place\r\n        );\r\n\r\n        hallRepository.saveAndFlush(hall);\r\n\r\n        mailSender.sendHall(file, hall.getId());\r\n\r\n        return new MessageCreateResponse(\r\n                \"The hall has been successfully created! Display wait for the administrator to check!\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Метод получения зала по id\r\n     * @param id зала\r\n     * @return зал\r\n     */\r\n    @Override\r\n    public Hall getHallById(Long id) {\r\n        log.trace(\"HallServiceImpl.getHallById - id {}\", id);\r\n        return hallRepository.getReferenceById(id);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/service/Impl/HallServiceImpl.java b/src/main/java/biletka/main/service/Impl/HallServiceImpl.java
--- a/src/main/java/biletka/main/service/Impl/HallServiceImpl.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/service/Impl/HallServiceImpl.java	(date 1715712403072)
@@ -46,10 +46,12 @@
     public MessageCreateResponse createHall(String authorization, MultipartFile file, HallCreateRequest hallCreateRequestNew) throws MessagingException, EntityNotFoundException {
         log.trace("HallServiceImpl.createHall - authorization {}, file {}, hallCreateRequestNew {}", authorization, file, hallCreateRequestNew);
         String typeFile = fileUtils.getFileExtension(file.getOriginalFilename());
+        ArrayList<String> pattern = new ArrayList<>();
+        pattern.add("svg");
 
         fileUtils.validationFile(
                 typeFile,
-                new String[]{"svg"}
+                pattern
         );
 
         String userEmail = jwtTokenUtils.getUsernameFromToken(
Index: src/main/java/biletka/main/Utils/FileUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package biletka.main.Utils;\r\n\r\nimport biletka.main.dto.universal.PublicEventImage;\r\nimport biletka.main.exception.ErrorMessage;\r\nimport biletka.main.exception.InvalidDataException;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport javax.imageio.ImageIO;\r\nimport javax.imageio.ImageReader;\r\nimport javax.imageio.stream.ImageInputStream;\r\nimport java.awt.*;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.*;\r\nimport java.net.URLConnection;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n@Component\r\n@Slf4j\r\npublic class FileUtils {\r\n    @Value(\"${app.file.directory}\")\r\n    private String directory;\r\n\r\n    /**\r\n     * метод получения типа файла и проверка на многотиповость\r\n     * @param fileName полновое название файла\r\n     * @return тип файла\r\n     */\r\n    public String getFileExtension(String fileName) {\r\n        Pattern pattern = Pattern.compile(\"\\\\.\");\r\n        String[] patternString = pattern.split(fileName);\r\n\r\n        if (patternString.length != 2) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"File error\", \"The file is incorrect!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n\r\n        return patternString[1];\r\n    }\r\n\r\n    /**\r\n     * Метод проверки тип файла с разрешенными\r\n     * @param typeFile тип файла\r\n     * @param pattern разрешенные типы файла\r\n     */\r\n    public void validationFile(String typeFile, String[] pattern) {\r\n        if (!Arrays.asList(pattern).contains(typeFile)) {\r\n            List<ErrorMessage> errorMessages = new ArrayList<>();\r\n            errorMessages.add(new ErrorMessage(\"File error\", \"The file is incorrect!\"));\r\n            throw new InvalidDataException(errorMessages);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод сохранения файла в системе\r\n     * @param file файла\r\n     */\r\n    public void fileUpload(MultipartFile file, String fileName) throws IOException {\r\n        File convertFile = new File(directory+fileName);\r\n        convertFile.createNewFile();\r\n        FileOutputStream fileOut = new FileOutputStream(convertFile);\r\n        fileOut.write(file.getBytes());\r\n        fileOut.close();\r\n    }\r\n\r\n    public PublicEventImage getFileEvent(String img) throws IOException {\r\n        /** Получение файла */\r\n        File file = new File(directory + \"event/\" + img);\r\n\r\n        /** Получение содержание файла в массиве байтов */\r\n        byte[] content = Files.readAllBytes(Paths.get(directory + \"event/\" + img));\r\n\r\n        /** Получение mime типа файла */\r\n        InputStream inputStream = new BufferedInputStream(new FileInputStream(file));\r\n        String mimeType = URLConnection.guessContentTypeFromStream(inputStream);\r\n\r\n        return new PublicEventImage(\r\n                content,\r\n                img,\r\n                mimeType\r\n        );\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/biletka/main/Utils/FileUtils.java b/src/main/java/biletka/main/Utils/FileUtils.java
--- a/src/main/java/biletka/main/Utils/FileUtils.java	(revision ceee08e78fe202d7d624880d794666861678b514)
+++ b/src/main/java/biletka/main/Utils/FileUtils.java	(date 1715712347909)
@@ -51,8 +51,11 @@
      * @param typeFile тип файла
      * @param pattern разрешенные типы файла
      */
-    public void validationFile(String typeFile, String[] pattern) {
-        if (!Arrays.asList(pattern).contains(typeFile)) {
+    public void validationFile(String typeFile, ArrayList<String> pattern) {
+        System.out.println(typeFile);
+        pattern.forEach(elem -> System.out.println(elem));
+        System.out.println(pattern.contains(typeFile));
+        if (!pattern.contains(typeFile)) {
             List<ErrorMessage> errorMessages = new ArrayList<>();
             errorMessages.add(new ErrorMessage("File error", "The file is incorrect!"));
             throw new InvalidDataException(errorMessages);
